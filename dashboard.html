<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MIX Location Data Dashboard</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
          integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
          crossorigin=""/>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        #sidebar {
            width: 320px;
            background: #ffffff;
            border-right: 1px solid #e5e7eb;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            transition: background 0.3s, border-color 0.3s;
        }

        body.dark-mode #sidebar {
            background: #1f2937;
            border-right-color: #374151;
        }

        #map {
            flex: 1;
            height: 100vh;
        }

        .sidebar-section {
            padding: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        body.dark-mode .sidebar-section {
            border-bottom-color: #374151;
        }

        body.dark-mode #build-info {
            border-top-color: #374151;
            color: #6b7280;
        }

        .sidebar-section h2 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 12px;
            color: #111827;
        }

        body.dark-mode .sidebar-section h2 {
            color: #f9fafb;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            font-size: 14px;
            color: #4b5563;
        }

        body.dark-mode .stat-item {
            color: #d1d5db;
        }

        .stat-value {
            font-weight: 600;
            color: #111827;
        }

        body.dark-mode .stat-value {
            color: #f9fafb;
        }

        .filter-group {
            margin-bottom: 16px;
        }

        .filter-group label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
            color: #374151;
        }

        body.dark-mode .filter-group label {
            color: #d1d5db;
        }

        .filter-group input[type="date"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
            background: #ffffff;
            color: #111827;
        }

        body.dark-mode .filter-group input[type="date"] {
            background: #374151;
            border-color: #4b5563;
            color: #f9fafb;
        }

        body.dark-mode #user-selector {
            background: #374151;
            border-color: #4b5563;
            color: #f9fafb;
        }

        body.dark-mode #user-stats {
            color: #9ca3af;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: #374151;
        }

        body.dark-mode .checkbox-item {
            color: #d1d5db;
        }

        .checkbox-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .toggle-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 0;
            font-size: 14px;
            color: #374151;
        }

        body.dark-mode .toggle-item {
            color: #d1d5db;
        }

        .toggle-switch {
            position: relative;
            width: 44px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #d1d5db;
            transition: 0.3s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: #3b82f6;
        }

        input:checked + .toggle-slider:before {
            transform: translateX(20px);
        }

        .legend {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #4b5563;
        }

        body.dark-mode .legend-item {
            color: #d1d5db;
        }

        .legend-item[data-legend] {
            cursor: pointer;
            padding: 4px;
            margin: -4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .legend-item[data-legend]:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .legend-item[data-legend].disabled {
            opacity: 0.4;
            text-decoration: line-through;
        }

        .legend-item[data-legend].disabled:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        .legend-marker {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            border: 1px solid rgba(0, 0, 0, 0.2);
        }

        #chart-container {
            height: 200px;
            margin-top: 12px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100vh;
            font-size: 18px;
            color: #6b7280;
        }

        .loading.loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            z-index: 1000;
        }

        body.dark-mode .loading {
            background: #111827;
            color: #9ca3af;
        }

        body.dark-mode .loading.loading-overlay {
            background: rgba(17, 24, 39, 0.9);
        }

        /* Card loading states */
        .analytics-card.card-loading .analytics-chart-container,
        .analytics-card.card-loading .stat-value,
        .metric-card.card-loading .metric-value {
            position: relative;
            overflow: hidden;
        }

        .analytics-card.card-loading .analytics-chart-container::after,
        .analytics-card.card-loading .stat-value::after,
        .metric-card.card-loading .metric-value::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(59, 130, 246, 0.08) 50%,
                transparent 100%
            );
            animation: loading-shimmer 2s infinite;
        }

        .analytics-card.card-loading .stat-value,
        .metric-card.card-loading .metric-value {
            color: #9ca3af !important;
            opacity: 0.5;
        }

        @keyframes loading-shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        /* Leaflet popup styling */
        .leaflet-popup-content-wrapper {
            border-radius: 8px;
        }

        body.dark-mode .leaflet-popup-content-wrapper {
            background: #1f2937;
            color: #f9fafb;
        }

        body.dark-mode .leaflet-popup-tip {
            background: #1f2937;
        }

        .popup-content {
            font-size: 13px;
            line-height: 1.6;
        }

        .popup-activity {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .popup-activity-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .popup-row {
            display: flex;
            justify-content: space-between;
            padding: 3px 0;
        }

        .popup-label {
            color: #6b7280;
            font-weight: 500;
        }

        body.dark-mode .popup-label {
            color: #9ca3af;
        }

        /* Mobile toggle button */
        .mobile-toggle {
            display: none;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #3b82f6;
            color: white;
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            font-size: 24px;
            align-items: center;
            justify-content: center;
            transition: transform 0.2s, background-color 0.2s;
        }

        .mobile-toggle:hover {
            transform: scale(1.05);
        }

        .mobile-toggle:active {
            transform: scale(0.95);
        }

        body.dark-mode .mobile-toggle {
            background: #2563eb;
        }

        .stat-description {
            font-size: 11px;
            color: #6b7280;
            margin-top: 2px;
            line-height: 1.3;
        }

        body.dark-mode .stat-description {
            color: #9ca3af;
        }

        /* Mobile responsive styles */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
            }

            #sidebar {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100%;
                z-index: 999;
                transform: translateY(100%);
                transition: transform 0.3s ease-out;
                border-right: none;
                border-top: 1px solid #e5e7eb;
            }

            body.dark-mode #sidebar {
                border-top-color: #374151;
            }

            #sidebar.mobile-open {
                transform: translateY(0);
            }

            #map {
                width: 100%;
                height: 100vh;
            }

            .mobile-toggle {
                display: flex;
            }

            .sidebar-section {
                padding: 16px;
            }

            .sidebar-section h2 {
                font-size: 16px;
            }

            /* Mobile close button at top of sidebar */
            .mobile-close {
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 12px 16px;
                background: #f3f4f6;
                border-bottom: 1px solid #e5e7eb;
            }

            body.dark-mode .mobile-close {
                background: #374151;
                border-bottom-color: #4b5563;
            }

            .mobile-close-title {
                font-weight: 600;
                font-size: 16px;
                color: #111827;
            }

            body.dark-mode .mobile-close-title {
                color: #f9fafb;
            }

            .mobile-close-btn {
                width: 32px;
                height: 32px;
                border-radius: 50%;
                background: #e5e7eb;
                border: none;
                cursor: pointer;
                font-size: 18px;
                color: #374151;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            body.dark-mode .mobile-close-btn {
                background: #4b5563;
                color: #d1d5db;
            }

            #chart-container {
                height: 150px;
            }

            .tab-nav {
                top: 12px;
            }
        }

        /* Floating Tab Navigation Styles */
        .tab-nav {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            display: flex;
            gap: 4px;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border-radius: 8px;
            padding: 4px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #e5e7eb;
        }

        body.dark-mode .tab-nav {
            background: rgba(31, 41, 55, 0.95);
            border-color: #374151;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .tab-btn {
            padding: 10px 24px;
            border: none;
            background: transparent;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: #6b7280;
            transition: all 0.2s;
            position: relative;
            border-radius: 6px;
        }

        body.dark-mode .tab-btn {
            color: #9ca3af;
        }

        .tab-btn:hover {
            color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .tab-btn.active {
            color: #ffffff;
            background: #3b82f6;
        }

        .tab-btn.active::after {
            display: none;
        }

        /* Analytics View Styles */
        #analytics-view {
            flex: 1;
            height: 100vh;
            overflow-y: auto;
            background: #f3f4f6;
            padding: 24px;
            display: none;
        }

        body.dark-mode #analytics-view {
            background: #111827;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 24px;
            max-width: 1800px;
            margin: 0 auto;
        }

        .analytics-card {
            background: #ffffff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .analytics-card {
            background: #1f2937;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .analytics-card h3 {
            font-size: 16px;
            font-weight: 600;
            margin-bottom: 4px;
            color: #111827;
        }

        body.dark-mode .analytics-card h3 {
            color: #f9fafb;
        }

        .analytics-card .card-description {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 16px;
        }

        body.dark-mode .analytics-card .card-description {
            color: #9ca3af;
        }

        .analytics-chart-container {
            height: 250px;
            position: relative;
        }

        .analytics-card.wide {
            grid-column: span 2;
        }

        .analytics-card.tall {
            grid-row: span 2;
        }

        /* Metric cards */
        .metrics-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .metric-card {
            background: #ffffff;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        body.dark-mode .metric-card {
            background: #1f2937;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        .metric-label {
            font-size: 12px;
            font-weight: 500;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 4px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        body.dark-mode .metric-label {
            color: #9ca3af;
        }

        .info-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #e5e7eb;
            color: #6b7280;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .info-icon {
            background: #374151;
            color: #9ca3af;
        }

        .info-icon:hover {
            background: #3b82f6;
            color: #ffffff;
        }

        .metric-explainer {
            margin: 0;
            padding: 16px;
            background: #ffffff;
            border: 1px solid #e5e7eb;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-size: 13px;
            line-height: 1.6;
            max-width: 400px;
            position: fixed;
            z-index: 1000;
        }

        body.dark-mode .metric-explainer {
            background: #1f2937;
            border-color: #374151;
            color: #f9fafb;
        }

        .metric-explainer::backdrop {
            background: rgba(0, 0, 0, 0.3);
        }

        .explainer-content strong {
            display: block;
            margin-bottom: 8px;
            color: #111827;
        }

        body.dark-mode .explainer-content strong {
            color: #f9fafb;
        }

        .explainer-content p {
            margin-bottom: 12px;
            color: #4b5563;
        }

        body.dark-mode .explainer-content p {
            color: #d1d5db;
        }

        .explainer-scale {
            background: #f3f4f6;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 12px;
        }

        body.dark-mode .explainer-scale {
            background: #111827;
        }

        .explainer-scale > div {
            padding: 4px 0;
            color: #4b5563;
        }

        body.dark-mode .explainer-scale > div {
            color: #d1d5db;
        }

        .scale-value {
            font-weight: 600;
            color: #3b82f6;
            margin-right: 8px;
        }

        .explainer-example {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 0;
        }

        body.dark-mode .explainer-example {
            color: #9ca3af;
        }

        .metric-value {
            font-size: 28px;
            font-weight: 700;
            color: #111827;
        }

        body.dark-mode .metric-value {
            color: #f9fafb;
        }

        .metric-detail {
            font-size: 12px;
            color: #6b7280;
            margin-top: 4px;
        }

        body.dark-mode .metric-detail {
            color: #9ca3af;
        }

        /* Heatmap styles */
        .heatmap-grid {
            display: grid;
            gap: 2px;
        }

        .heatmap-cell {
            width: 100%;
            aspect-ratio: 1;
            border-radius: 2px;
            min-width: 8px;
            min-height: 8px;
        }

        .heatmap-labels {
            display: flex;
            justify-content: space-between;
            font-size: 10px;
            color: #6b7280;
            margin-top: 8px;
        }

        body.dark-mode .heatmap-labels {
            color: #9ca3af;
        }

        .heatmap-row-label {
            font-size: 10px;
            color: #6b7280;
            text-align: right;
            padding-right: 4px;
        }

        body.dark-mode .heatmap-row-label {
            color: #9ca3af;
        }

        /* Thesis metrics highlight */
        .thesis-metric {
            border-left: 4px solid #3b82f6;
        }

        .thesis-badge {
            display: inline-block;
            background: #dbeafe;
            color: #1d4ed8;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            vertical-align: middle;
        }

        body.dark-mode .thesis-badge {
            background: #1e3a5f;
            color: #60a5fa;
        }

        /* Experimental warning banner */
        .experimental-warning {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            color: #78350f;
            padding: 12px 20px;
            border-radius: 8px;
            margin-bottom: 24px;
            font-size: 14px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 2px 4px rgba(251, 191, 36, 0.3);
        }

        body.dark-mode .experimental-warning {
            background: linear-gradient(135deg, #92400e 0%, #78350f 100%);
            color: #fbbf24;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }

        /* Dwell statistics dark mode support */
        body.dark-mode #dwell-stats-display > div {
            border-bottom-color: #374151;
        }

        body.dark-mode #dwell-stats-display span:first-child {
            color: #9ca3af;
        }

        body.dark-mode #dwell-stats-display span:last-child {
            color: #f9fafb;
        }

        /* Responsive analytics */
        @media (max-width: 1200px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }
            .analytics-card.wide {
                grid-column: span 1;
            }
            .metrics-row {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            #analytics-view {
                padding: 16px;
            }
            .metrics-row {
                grid-template-columns: 1fr;
            }
            .analytics-chart-container {
                height: 200px;
            }
            .tab-nav {
                top: 12px;
            }
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading data...</div>

    <!-- Mobile toggle button -->
    <button id="mobile-toggle" class="mobile-toggle" style="display: none;" aria-label="Toggle filters">
        ☰
    </button>

    <!-- Floating Tab Navigation -->
    <nav class="tab-nav">
        <button class="tab-btn active" data-tab="map">Map View</button>
        <button class="tab-btn" data-tab="analytics">Analytics</button>
    </nav>

    <div id="sidebar" style="display: none;">
        <div id="mobile-close" class="mobile-close" style="display: none;">
            <span class="mobile-close-title">Filters & Stats</span>
            <button class="mobile-close-btn" aria-label="Close filters">✕</button>
        </div>

        <!-- User Selector -->
        <div class="sidebar-section" style="padding-bottom: 12px;">
            <h2>User</h2>
            <div class="filter-group" style="margin-bottom: 0;">
                <select id="user-selector" style="width: 100%; padding: 8px; border: 1px solid #d1d5db; border-radius: 6px; font-size: 14px; background: #ffffff; color: #111827; cursor: pointer;">
                    <option value="qaCPu4bNgYOFsjQaSRjjMb4fJRf2">Loading users...</option>
                </select>
                <div id="user-stats" style="font-size: 11px; color: #6b7280; margin-top: 6px;"></div>
            </div>
        </div>

        <div class="sidebar-section">
            <h2>Data Summary</h2>
            <div class="stat-item">
                <div>
                    <span>Total Locations</span>
                    <div class="stat-description">Continuous GPS tracking points</div>
                </div>
                <span class="stat-value" id="stat-locations">0</span>
            </div>
            <div class="stat-item">
                <div>
                    <span>Total Visits</span>
                    <div class="stat-description">Detected stops at places</div>
                </div>
                <span class="stat-value" id="stat-visits">0</span>
            </div>
            <div class="stat-item">
                <span>Date Range</span>
                <span class="stat-value" id="stat-daterange">-</span>
            </div>
        </div>

        <div class="sidebar-section">
            <h2>Date Filters</h2>
            <div class="filter-group">
                <label for="date-start">Start Date</label>
                <input type="date" id="date-start">
            </div>
            <div class="filter-group">
                <label for="date-end">End Date</label>
                <input type="date" id="date-end">
            </div>
        </div>

        <div class="sidebar-section">
            <h2>Layers</h2>
            <div class="toggle-item">
                <span>Location Points</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="toggle-locations" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
            <div class="toggle-item">
                <span>Visits</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="toggle-visits" checked>
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>

        <div class="sidebar-section">
            <h2>Activity Filter</h2>
            <div class="checkbox-group">
                <label class="checkbox-item">
                    <input type="checkbox" data-activity="stationary" checked>
                    <span>Stationary</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" data-activity="walking" checked>
                    <span>Walking</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" data-activity="running" checked>
                    <span>Running</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" data-activity="cycling" checked>
                    <span>Cycling</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" data-activity="automotive" checked>
                    <span>Automotive</span>
                </label>
                <label class="checkbox-item">
                    <input type="checkbox" data-activity="unknown" checked>
                    <span>Unknown</span>
                </label>
            </div>
        </div>

        <div class="sidebar-section">
            <h2>Upload Frequency</h2>
            <div id="chart-container">
                <canvas id="frequency-chart"></canvas>
            </div>
        </div>

        <div class="sidebar-section">
            <h2>Legend</h2>
            <div class="legend">
                <div class="legend-item" data-legend="stationary" title="Click to toggle">
                    <div class="legend-color" style="background: #9333ea;"></div>
                    <span>Stationary</span>
                </div>
                <div class="legend-item" data-legend="walking" title="Click to toggle">
                    <div class="legend-color" style="background: #22c55e;"></div>
                    <span>Walking</span>
                </div>
                <div class="legend-item" data-legend="running" title="Click to toggle">
                    <div class="legend-color" style="background: #f97316;"></div>
                    <span>Running</span>
                </div>
                <div class="legend-item" data-legend="cycling" title="Click to toggle">
                    <div class="legend-color" style="background: #3b82f6;"></div>
                    <span>Cycling</span>
                </div>
                <div class="legend-item" data-legend="automotive" title="Click to toggle">
                    <div class="legend-color" style="background: #ef4444;"></div>
                    <span>Automotive</span>
                </div>
                <div class="legend-item" data-legend="unknown" title="Click to toggle">
                    <div class="legend-color" style="background: #9ca3af;"></div>
                    <span>Unknown</span>
                </div>
                <div class="legend-item" data-legend="visits" title="Click to toggle visits">
                    <div class="legend-marker" style="background: #22c55e;"></div>
                    <span>Visit Arrival</span>
                </div>
                <div class="legend-item" data-legend="visits" title="Click to toggle visits">
                    <div class="legend-marker" style="background: #ef4444;"></div>
                    <span>Visit Departure</span>
                </div>
            </div>
        </div>

        <!-- Build Info -->
        <div id="build-info" style="padding: 12px 20px; font-size: 10px; color: #9ca3af; border-top: 1px solid #e5e7eb; margin-top: auto;">
            <span id="build-commit">Loading...</span>
        </div>
    </div>

    <div id="map" style="display: none;"></div>

    <!-- Analytics View -->
    <div id="analytics-view">
        <!-- Experimental Warning Banner -->
        <div class="experimental-warning">
            <span style="font-size: 18px;">⚠️</span>
            <span>Experimental Analytics - These metrics are under development and may not be accurate</span>
        </div>
        <!-- Key Metrics Row -->
        <div class="metrics-row">
            <div class="metric-card thesis-metric" style="position: relative;">
                <div class="metric-label">Mobility Entropy <span class="info-icon" id="entropy-info-icon">?</span></div>
                <div class="metric-value" id="metric-entropy">--</div>
                <div class="metric-detail">Shannon entropy of location visits</div>
                <div id="entropy-explainer" class="metric-explainer" popover>
                    <div class="explainer-content">
                        <strong>What is Mobility Entropy?</strong>
                        <p>Measures diversity in your location patterns. Higher = more varied/unpredictable movement. Lower = more routine behavior.</p>
                        <div class="explainer-scale">
                            <div><span class="scale-value">0-1</span> Highly routine (one dominant location)</div>
                            <div><span class="scale-value">1-2</span> Balanced (2-4 regular locations)</div>
                            <div><span class="scale-value">2+</span> Diverse, unpredictable movement</div>
                        </div>
                        <p class="explainer-example"><strong>Example:</strong> Visiting 3 places equally = 1.58 bits. Visiting one place 90% of the time = ~0.5 bits.</p>
                    </div>
                </div>
            </div>
            <div class="metric-card thesis-metric">
                <div class="metric-label">Away Dwell Time</div>
                <div class="metric-value" id="metric-dwell">--</div>
                <div class="metric-detail">Average time spent at non-home locations per visit</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Total Distance</div>
                <div class="metric-value" id="metric-distance">--</div>
                <div class="metric-detail">Estimated distance traveled</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Active Days</div>
                <div class="metric-value" id="metric-active-days">--</div>
                <div class="metric-detail">Days with location data</div>
            </div>
        </div>

        <!-- Analytics Charts Grid -->
        <div class="analytics-grid">
            <!-- Home Detection Card -->
            <div class="analytics-card">
                <h3>Home Detection <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Auto-detected home clusters from nighttime (22:00-06:00) location density</p>
                <div class="analytics-chart-container">
                    <div id="home-detection-map" style="height: 250px;"></div>
                </div>
            </div>

            <!-- Daily Exploration Radius -->
            <div class="analytics-card thesis-metric">
                <h3>Daily Exploration Radius <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Maximum distance from nearest home each day (km)</p>
                <div class="analytics-chart-container">
                    <canvas id="daily-exploration-chart"></canvas>
                </div>
            </div>

            <!-- Home vs Away Time -->
            <div class="analytics-card wide thesis-metric">
                <h3>Home vs Away Time <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Hours spent at home (&lt;500m from any detected home) vs away by day</p>
                <div class="analytics-chart-container" style="height: 200px;">
                    <canvas id="home-away-chart"></canvas>
                </div>
            </div>

            <!-- Exploration Consistency -->
            <div class="analytics-card">
                <h3>Exploration Consistency <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Standard deviation of daily radius - high variance = exploratory, low = routine</p>
                <div class="analytics-chart-container">
                    <div id="exploration-variance-display" style="height: 250px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <div style="font-size: 64px; font-weight: 700; color: #3b82f6;" id="variance-value">--</div>
                        <div style="font-size: 14px; color: #6b7280; margin-top: 8px;">km std deviation</div>
                        <div style="font-size: 12px; color: #9ca3af; margin-top: 16px; text-align: center;" id="variance-label">--</div>
                    </div>
                </div>
            </div>

            <!-- Radius of Gyration -->
            <div class="analytics-card wide thesis-metric">
                <h3>Radius of Gyration Over Time <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Daily spatial spread from your activity centroid. Only includes days where you started and ended at the same home location (excludes travel days).</p>
                <div class="analytics-chart-container" style="height: 200px;">
                    <canvas id="radius-gyration-chart"></canvas>
                </div>
            </div>

            <!-- Dwell Time Distribution -->
            <div class="analytics-card thesis-metric">
                <h3>Dwell Time Distribution <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Distribution of visit durations at non-home places</p>
                <div class="analytics-chart-container">
                    <canvas id="dwell-distribution-chart"></canvas>
                </div>
            </div>

            <!-- Dwell Time Statistics -->
            <div class="analytics-card thesis-metric" id="dwell-stats-card">
                <h3>Dwell Time Statistics <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Statistical measures of time spent at non-home locations</p>
                <div class="analytics-chart-container">
                    <div id="dwell-stats-display" style="height: 250px; display: flex; flex-direction: column; justify-content: center; padding: 20px;">
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;">
                            <span style="color: #6b7280; font-size: 14px;">Median Dwell Time</span>
                            <span class="stat-value" style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-median">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;">
                            <span style="color: #6b7280; font-size: 14px;">25th Percentile</span>
                            <span class="stat-value" style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-p25">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;">
                            <span style="color: #6b7280; font-size: 14px;">75th Percentile</span>
                            <span class="stat-value" style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-p75">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;">
                            <span style="color: #6b7280; font-size: 14px;">Unique Places Visited</span>
                            <span class="stat-value" style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-unique-places">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0;">
                            <span style="color: #6b7280; font-size: 14px;">Total Away Visits</span>
                            <span class="stat-value" style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-total-visits">--</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Walk Score Section Header -->
            <div class="analytics-card wide" id="walkscore-header" style="background: linear-gradient(135deg, #1e40af 0%, #3b82f6 100%); color: white; padding: 16px;">
                <h3 style="color: white; margin-bottom: 4px;">Walk Score Analytics <span class="thesis-badge" style="background: rgba(255,255,255,0.2); color: white;">Walkability</span></h3>
                <p class="card-description" style="color: rgba(255,255,255,0.8); margin-bottom: 8px;">Contextualizing walking behavior against neighborhood walkability scores (excludes home locations)</p>
                <details style="font-size: 11px; margin-top: 4px; color: rgba(255,255,255,0.7);">
                    <summary style="cursor: pointer;">ℹ️ How this works</summary>
                    <div style="margin-top: 8px; line-height: 1.5;">
                        <strong>Walk Score</strong> (0-100) measures how walkable an area is based on proximity to amenities.<br>
                        • 90-100: Walker's Paradise • 70-89: Very Walkable • 50-69: Somewhat Walkable • 0-49: Car-Dependent<br><br>
                        <strong>Walking Rate</strong> calculation: GPS points are grouped into ~200m grid cells. Each point is matched to the nearest motion sensor reading (within 90 seconds). Walking Rate = (walking points / total points) × 100%. Example: 10 points in a cell (3 walking, 5 stationary, 2 unknown) → 30% walking rate. "Unknown" motion states count as non-walking.<br><br>
                        <strong>Efficiency Index</strong> = (Your Walking %) ÷ (Expected Walking %). Expected rate assumes Walk Score 100 → ~70% walking max, scaling linearly.<br><br>
                        All metrics exclude locations within 500m of detected home(s) to show true "out and about" behavior.
                    </div>
                </details>
                <div id="walkscore-status" style="font-size: 11px; margin-top: 6px; color: rgba(255,255,255,0.7); line-height: 1.4;">
                    Loading Walk Score data...
                </div>
            </div>

            <!-- Walking Efficiency Index -->
            <div class="analytics-card" id="walking-efficiency-card">
                <h3>Walking Efficiency <span class="thesis-badge">Walkability</span></h3>
                <p class="card-description" title="Formula: (Actual Walking %) / (Expected Walking %). Expected = Walk Score × 0.7. Example: Walk Score 80 → expect ~56% walking.">Are you walking as much as your environment enables? <span style="color: #9ca3af; cursor: help;">ⓘ</span></p>
                <div class="analytics-chart-container">
                    <div id="walking-efficiency-display" style="height: 250px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                        <div id="efficiency-value" style="font-size: 64px; font-weight: 700; color: #3b82f6;">--</div>
                        <div style="font-size: 14px; color: #6b7280; margin-top: 8px;">efficiency index</div>
                        <div id="efficiency-label" style="font-size: 12px; color: #9ca3af; margin-top: 16px; text-align: center;">
                            1.0 = walking as expected for walkability
                        </div>
                    </div>
                </div>
            </div>

            <!-- Time by Walkability Zone -->
            <div class="analytics-card" id="walkability-zone-card">
                <h3>Time by Walkability <span class="thesis-badge">Walkability</span></h3>
                <p class="card-description" title="Time spent at away-from-home locations grouped by Walk Score zone. High=70-100, Medium=50-69, Low=25-49, Very Low=0-24.">Hours spent in areas by Walk Score category (away from home) <span style="color: #9ca3af; cursor: help;">ⓘ</span></p>
                <div class="analytics-chart-container">
                    <canvas id="walkability-zone-chart"></canvas>
                </div>
            </div>

            <!-- Walking Rate vs Walk Score -->
            <div class="analytics-card wide">
                <h3>Walking Rate vs Walkability <span class="thesis-badge">Walkability</span></h3>
                <p class="card-description" title="Each bubble is a ~200m grid cell you visited. X-axis: Walk Score of that area. Y-axis: % of time you were walking there. Bubble size = time spent. Dashed line shows expected walking rate.">Your walking % at each location vs its Walk Score <span style="color: #9ca3af; cursor: help;">ⓘ</span></p>
                <div class="analytics-chart-container" style="height: 200px;">
                    <canvas id="walking-vs-walkscore-chart"></canvas>
                </div>
            </div>

            <!-- Walk Score Statistics -->
            <div class="analytics-card" id="walkscore-stats-card">
                <h3>Walkability Statistics <span class="thesis-badge">Walkability</span></h3>
                <p class="card-description">Summary across away-from-home locations</p>
                <div class="analytics-chart-container">
                    <div id="walkscore-stats-display" style="height: 250px; display: flex; flex-direction: column; justify-content: center; padding: 20px;">
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;" title="Simple average of Walk Scores across all visited grid cells">
                            <span style="color: #6b7280; font-size: 14px;">Avg Walk Score <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-avg-walkscore">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;" title="Walk Score weighted by time spent at each location - reflects where you actually spend time">
                            <span style="color: #6b7280; font-size: 14px;">Time-Weighted Avg <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-weighted-walkscore">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;" title="% of time spent walking in areas with Walk Score ≥70">
                            <span style="color: #6b7280; font-size: 14px;">Walking in High (70+) <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-walking-high">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0;" title="% of time spent walking in areas with Walk Score <50">
                            <span style="color: #6b7280; font-size: 14px;">Walking in Low (<50) <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-walking-low">--</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Place Attachment -->
            <div class="analytics-card wide" id="place-attachment-card">
                <h3>Place Attachment <span class="thesis-badge">Spatial</span></h3>
                <p class="card-description">Personally significant places based on visit frequency, dwell duration, and temporal regularity</p>
                <div class="analytics-chart-container" style="height: auto; min-height: 300px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 100%;">
                        <!-- Left: Stats and Top Places List -->
                        <div style="display: flex; flex-direction: column;">
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--mix-border);">
                                <span style="color: var(--mix-text-muted); font-size: 12px;">High-Attachment Places</span>
                                <span style="color: var(--mix-text); font-size: 14px; font-weight: 600;" id="stat-high-attachment-count">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid var(--mix-border);">
                                <span style="color: var(--mix-text-muted); font-size: 12px;">Avg Visits (Top Places)</span>
                                <span style="color: var(--mix-text); font-size: 14px; font-weight: 600;" id="stat-avg-visits-top">--</span>
                            </div>
                            <div style="margin-top: 16px; overflow-y: auto; flex: 1;">
                                <table id="attachment-table" style="width: 100%; font-size: 11px; border-collapse: collapse;">
                                    <thead>
                                        <tr style="border-bottom: 1px solid var(--mix-border); color: var(--mix-text-muted);">
                                            <th style="text-align: left; padding: 6px 4px; font-weight: 600;">Rank</th>
                                            <th style="text-align: left; padding: 6px 4px; font-weight: 600;">Location</th>
                                            <th style="text-align: right; padding: 6px 4px; font-weight: 600;">Score</th>
                                            <th style="text-align: right; padding: 6px 4px; font-weight: 600;">Visits</th>
                                        </tr>
                                    </thead>
                                    <tbody id="attachment-table-body">
                                        <tr><td colspan="4" style="text-align: center; padding: 20px; color: var(--mix-text-muted);">Calculating...</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        <!-- Right: Mini Map -->
                        <div id="attachment-map" style="height: 280px; border-radius: 8px; background: var(--mix-card-bg);"></div>
                    </div>
                </div>
            </div>

            <!-- Activity Inference Section Header -->
            <div class="analytics-card wide" style="background: linear-gradient(135deg, #7c3aed 0%, #a855f7 100%); color: white;">
                <h3 style="color: white;">Activity Inference <span class="thesis-badge" style="background: rgba(255,255,255,0.2); color: white;">Speed Analysis</span></h3>
                <p class="card-description" style="color: rgba(255,255,255,0.8);">Inferring activity types from GPS movement speed when motion sensors report "unknown"</p>

                <!-- Key Metrics Summary -->
                <div id="inference-summary" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 16px; margin-top: 16px; padding: 16px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                    <div style="text-align: center;">
                        <div id="inference-metric-points" style="font-size: 24px; font-weight: 700;">--</div>
                        <div style="font-size: 11px; opacity: 0.8;">Point Pairs</div>
                    </div>
                    <div style="text-align: center;">
                        <div id="inference-metric-agreement" style="font-size: 24px; font-weight: 700;">--</div>
                        <div style="font-size: 11px; opacity: 0.8;">Agreement Rate</div>
                    </div>
                    <div style="text-align: center;">
                        <div id="inference-metric-reclassified" style="font-size: 24px; font-weight: 700;">--</div>
                        <div style="font-size: 11px; opacity: 0.8;">Unknown → Classified</div>
                    </div>
                    <div style="text-align: center;">
                        <div id="inference-metric-walking" style="font-size: 24px; font-weight: 700;">--</div>
                        <div style="font-size: 11px; opacity: 0.8;">Walking Distance</div>
                    </div>
                </div>

                <details style="font-size: 11px; margin-top: 12px; color: rgba(255,255,255,0.7);">
                    <summary style="cursor: pointer;">ℹ️ How this works</summary>
                    <div style="margin-top: 8px; line-height: 1.6;">
                        <strong>Speed Calculation:</strong> Distance between consecutive GPS points ÷ time elapsed.<br>
                        Uses Haversine formula for accurate spherical distance.<br><br>
                        <strong>Speed Thresholds (research-based):</strong><br>
                        • Stationary: &lt;0.15 m/s (0.5 km/h)<br>
                        • Walking: 0.15-2.0 m/s (0.5-7.2 km/h)<br>
                        • Cycling: 2.0-8.0 m/s (7.2-29 km/h)<br>
                        • Driving: &gt;8.0 m/s (29+ km/h)<br><br>
                        <strong>Likely Walking Routes:</strong> Consecutive segments where speed stays in walking range for 3+ points with directional movement (not just stationary).
                    </div>
                </details>
                <div id="inference-status" style="font-size: 12px; margin-top: 8px; color: rgba(255,255,255,0.7);">
                    Analyzing GPS trajectories...
                </div>
            </div>

            <!-- Inferred Activity Distribution -->
            <div class="analytics-card">
                <h3>Inferred Activity <span class="thesis-badge">Speed</span></h3>
                <p class="card-description" title="Activity type inferred from speed between consecutive GPS points. Based on academic research thresholds.">Speed-based activity classification <span style="color: #9ca3af; cursor: help;">ⓘ</span></p>
                <div class="analytics-chart-container">
                    <canvas id="inferred-activity-chart"></canvas>
                </div>
            </div>

            <!-- Sensor vs Inferred Comparison -->
            <div class="analytics-card">
                <h3>Sensor vs Inferred <span class="thesis-badge">Speed</span></h3>
                <p class="card-description" title="Comparing motion sensor data with speed-based inference. Shows agreement/disagreement rates.">How well does speed match sensor data? <span style="color: #9ca3af; cursor: help;">ⓘ</span></p>
                <div class="analytics-chart-container">
                    <canvas id="sensor-vs-inferred-chart"></canvas>
                </div>
            </div>

            <!-- Speed Distribution Histogram -->
            <div class="analytics-card wide">
                <h3>Speed Distribution <span class="thesis-badge">Speed</span></h3>
                <p class="card-description" title="Histogram of calculated speeds between GPS points. Shows natural clusters that may indicate different activity types.">Distribution of movement speeds <span style="color: #9ca3af; cursor: help;">ⓘ</span></p>
                <div class="analytics-chart-container" style="height: 200px;">
                    <canvas id="speed-histogram-chart"></canvas>
                </div>
            </div>

            <!-- Walking Route Statistics -->
            <div class="analytics-card">
                <h3>Likely Walking Routes <span class="thesis-badge">Speed</span></h3>
                <p class="card-description" title="Consecutive GPS segments where speed indicates walking (0.15-2.0 m/s) for 3+ points">Detected walking-speed segments</p>
                <div class="analytics-chart-container">
                    <div id="walking-routes-display" style="height: 250px; display: flex; flex-direction: column; justify-content: center; padding: 20px;">
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;" title="Number of continuous segments with walking-speed movement">
                            <span style="color: #6b7280; font-size: 14px;">Walking Segments <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-walking-segments">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;" title="Total distance of all likely walking routes">
                            <span style="color: #6b7280; font-size: 14px;">Total Walking Distance <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-walking-distance">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0; border-bottom: 1px solid #e5e7eb;" title="Average speed during inferred walking segments">
                            <span style="color: #6b7280; font-size: 14px;">Avg Walking Speed <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-avg-walking-speed">--</span>
                        </div>
                        <div style="display: flex; justify-content: space-between; padding: 12px 0;" title="Percentage of GPS points that were reclassified from 'unknown' to a specific activity">
                            <span style="color: #6b7280; font-size: 14px;">Unknown Reclassified <span style="color: #9ca3af; cursor: help;">ⓘ</span></span>
                            <span style="color: #111827; font-size: 18px; font-weight: 600;" id="stat-reclassified">--</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
            integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
            crossorigin=""></script>

    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js';
        import { getFirestore, collection, query, where, orderBy, getDocs, Timestamp } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js';
        import { getFunctions, httpsCallable } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-functions.js';

        // Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyDOAuOCT4_N2-erb_lWPYYdv1buhYvMXcg",
            authDomain: "suelio-ar.firebaseapp.com",
            projectId: "suelio-ar",
            storageBucket: "suelio-ar.appspot.com",
            messagingSenderId: "182810396935",
            appId: "1:182810396935:web:f8e8f8f8f8f8f8f8f8f8f8"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const functions = getFunctions(app);

        // Default user ID (can be changed via user selector)
        const DEFAULT_USER_ID = 'qaCPu4bNgYOFsjQaSRjjMb4fJRf2';

        // Make Firestore available globally
        window.firestoreDB = db;
        window.firestoreQuery = query;
        window.firestoreCollection = collection;
        window.firestoreWhere = where;
        window.firestoreOrderBy = orderBy;
        window.firestoreGetDocs = getDocs;
        window.firestoreTimestamp = Timestamp;

        // Make Functions available globally
        window.firebaseFunctions = functions;
        window.httpsCallable = httpsCallable;
        window.FIRESTORE_USER_ID = DEFAULT_USER_ID;
        window.DEFAULT_USER_ID = DEFAULT_USER_ID;
        window.firebaseReady = true;

        // Function to load all available users from Firestore
        window.loadAvailableUsers = async function() {
            const usersMap = new Map();

            // Query each collection for distinct userIds
            const collections = ['user_locations', 'user_motion_activities', 'user_visits'];

            for (const colName of collections) {
                try {
                    const snapshot = await getDocs(collection(db, colName));
                    snapshot.forEach(doc => {
                        const userId = doc.data().userId;
                        if (!userId || userId.startsWith('test')) return;

                        if (!usersMap.has(userId)) {
                            usersMap.set(userId, {
                                locations: 0, motion: 0, visits: 0,
                                minDate: null, maxDate: null
                            });
                        }

                        const stats = usersMap.get(userId);
                        if (colName === 'user_locations') stats.locations++;
                        else if (colName === 'user_motion_activities') stats.motion++;
                        else if (colName === 'user_visits') stats.visits++;

                        // Track date range
                        const ts = doc.data().serverTimestamp || doc.data().timestamp || doc.data().arrivalDate;
                        if (ts) {
                            const date = ts.toDate ? ts.toDate() : new Date(ts);
                            if (!stats.minDate || date < stats.minDate) stats.minDate = date;
                            if (!stats.maxDate || date > stats.maxDate) stats.maxDate = date;
                        }
                    });
                } catch (e) {
                    console.warn(`Error loading ${colName}:`, e);
                }
            }

            return usersMap;
        };

        // Dispatch event when Firebase is ready
        window.dispatchEvent(new Event('firebaseReady'));
    </script>

    <script>
        // Parse dates as local time (not UTC)
        function parseLocalDate(dateString) {
            const [year, month, day] = dateString.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        // Activity color mapping
        const ACTIVITY_COLORS = {
            stationary: '#9333ea',
            walking: '#22c55e',
            running: '#f97316',
            cycling: '#3b82f6',
            automotive: '#ef4444',
            unknown: '#9ca3af'
        };

        // Maximum time difference between location and motion to consider a match
        const MAX_MOTION_MATCH_SECONDS = 90; // Maximum seconds between location and motion to consider a match

        // Confidence mapping
        const CONFIDENCE_LABELS = {
            0: 'Low',
            1: 'Medium',
            2: 'High'
        };

        // Global state
        let map;
        let locationsData = [];
        let motionData = [];
        let visitsData = [];
        let locationMarkers = [];
        let visitMarkers = [];
        let chart;
        let availableUsers = new Map(); // userId -> stats

        // ============================================================
        // USER SWITCHING
        // ============================================================

        // Populate user selector dropdown
        async function populateUserSelector() {
            const selector = document.getElementById('user-selector');
            const statsEl = document.getElementById('user-stats');

            selector.innerHTML = '<option value="">Loading users...</option>';
            statsEl.textContent = 'Scanning database...';

            try {
                availableUsers = await window.loadAvailableUsers();

                // Sort by total records (most data first)
                const sorted = [...availableUsers.entries()].sort((a, b) => {
                    const totalA = a[1].locations + a[1].motion + a[1].visits;
                    const totalB = b[1].locations + b[1].motion + b[1].visits;
                    return totalB - totalA;
                });

                selector.innerHTML = '';
                sorted.forEach(([userId, stats], index) => {
                    const total = stats.locations + stats.motion + stats.visits;
                    const option = document.createElement('option');
                    option.value = userId;

                    // Create display label (truncate long IDs)
                    const shortId = userId.length > 12 ? userId.substring(0, 12) + '...' : userId;
                    const isDefault = userId === window.DEFAULT_USER_ID;
                    option.textContent = `${shortId} (${total.toLocaleString()} pts)${isDefault ? ' ★' : ''}`;
                    option.title = userId; // Full ID on hover

                    if (userId === window.FIRESTORE_USER_ID) {
                        option.selected = true;
                    }

                    selector.appendChild(option);
                });

                // Update stats display
                updateUserStatsDisplay();

                statsEl.textContent = `${availableUsers.size} users found`;
            } catch (error) {
                console.error('Error loading users:', error);
                selector.innerHTML = `<option value="${window.DEFAULT_USER_ID}">Default User</option>`;
                statsEl.textContent = 'Error loading users';
            }
        }

        // Update the user stats display below selector
        function updateUserStatsDisplay() {
            const statsEl = document.getElementById('user-stats');
            const userId = window.FIRESTORE_USER_ID;
            const stats = availableUsers.get(userId);

            if (stats) {
                const dateRange = stats.minDate && stats.maxDate
                    ? `${stats.minDate.toLocaleDateString()} - ${stats.maxDate.toLocaleDateString()}`
                    : 'No dates';
                statsEl.textContent = `${stats.locations.toLocaleString()} locs · ${stats.motion.toLocaleString()} motion · ${dateRange}`;
            }
        }

        // Handle user change
        async function onUserChange() {
            const selector = document.getElementById('user-selector');
            const newUserId = selector.value;

            if (!newUserId || newUserId === window.FIRESTORE_USER_ID) return;

            // Update global user ID
            window.FIRESTORE_USER_ID = newUserId;

            // Clear Walk Score cache (it's user-specific)
            try {
                localStorage.removeItem('walkscore_cache_v1');
            } catch (e) {}

            // Get user's date range
            const stats = availableUsers.get(newUserId);
            let startDate, endDate;

            if (stats && stats.minDate && stats.maxDate) {
                // Use user's data range, but cap to last 30 days if longer
                endDate = new Date(Math.min(stats.maxDate.getTime(), Date.now()));
                endDate.setHours(23, 59, 59, 999);

                const thirtyDaysAgo = new Date(endDate);
                thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

                startDate = new Date(Math.max(stats.minDate.getTime(), thirtyDaysAgo.getTime()));
                startDate.setHours(0, 0, 0, 0);
            } else {
                // Default to last 30 days
                endDate = new Date();
                endDate.setHours(23, 59, 59, 999);
                startDate = new Date();
                startDate.setDate(startDate.getDate() - 30);
                startDate.setHours(0, 0, 0, 0);
            }

            // Update date inputs
            document.getElementById('date-start').value = startDate.toISOString().split('T')[0];
            document.getElementById('date-end').value = endDate.toISOString().split('T')[0];

            // Update stats display
            updateUserStatsDisplay();

            // Show loading
            const loadingEl = document.getElementById('loading');
            loadingEl.textContent = 'Switching user...';
            loadingEl.classList.add('loading-overlay');
            loadingEl.style.display = 'flex';

            try {
                // Reload data for new user
                await queryFirestoreData(startDate, endDate);

                // Update all displays
                updateStats();
                if (chart) chart.destroy();
                createFrequencyChart();
                renderLocations();
                renderVisits();

                // If on analytics tab, refresh analytics
                const analyticsView = document.getElementById('analytics-view');
                if (analyticsView && analyticsView.style.display !== 'none') {
                    renderAnalytics();
                }

            } catch (error) {
                console.error('Error switching user:', error);
                alert('Error loading user data: ' + error.message);
            } finally {
                loadingEl.style.display = 'none';
                loadingEl.classList.remove('loading-overlay');
            }
        }

        // ============================================================
        // END USER SWITCHING
        // ============================================================

        // Detect dark mode
        function isDarkMode() {
            return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        }

        // Apply dark mode
        function applyDarkMode() {
            if (isDarkMode()) {
                document.body.classList.add('dark-mode');
            } else {
                document.body.classList.remove('dark-mode');
            }
        }

        // Initialize map
        function initMap() {
            const darkMode = isDarkMode();
            const tileUrl = darkMode
                ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';

            map = L.map('map').setView([0, 0], 2);

            L.tileLayer(tileUrl, {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19,
                detectRetina: true
            }).addTo(map);
        }

        // Binary search to find nearest motion activity by timestamp
        function findNearestMotion(timestamp, motionArray) {
            if (!motionArray || motionArray.length === 0) {
                return null;
            }

            let left = 0;
            let right = motionArray.length - 1;
            let closest = null;
            let minDiff = Infinity;

            while (left <= right) {
                const mid = Math.floor((left + right) / 2);
                const motion = motionArray[mid];
                const diff = Math.abs(new Date(motion.timestamp).getTime() - new Date(timestamp).getTime());

                if (diff < minDiff) {
                    minDiff = diff;
                    closest = motion;
                }

                if (new Date(motion.timestamp).getTime() < new Date(timestamp).getTime()) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            // Return null if the time difference exceeds the threshold
            if (minDiff > MAX_MOTION_MATCH_SECONDS * 1000) {
                return null;
            }

            return closest;
        }

        // Determine activity type from motion data
        function getActivityType(motion) {
            if (!motion) return 'unknown';
            if (motion.isStationary) return 'stationary';
            if (motion.isWalking) return 'walking';
            if (motion.isRunning) return 'running';
            if (motion.isCycling) return 'cycling';
            if (motion.isAutomotive) return 'automotive';
            return 'unknown';
        }

        // Create popup content
        function createPopupContent(location, activity, motion) {
            const activityColor = ACTIVITY_COLORS[activity];
            const confidence = motion ? CONFIDENCE_LABELS[motion.confidence] || 'Unknown' : 'Unknown';
            const timestamp = new Date(location.timestamp).toLocaleString();

            return `
                <div class="popup-content">
                    <div class="popup-activity">
                        <div class="popup-activity-dot" style="background: ${activityColor};"></div>
                        <span>${activity.charAt(0).toUpperCase() + activity.slice(1)}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Confidence:</span>
                        <span>${confidence}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Time:</span>
                        <span>${timestamp}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Lat/Lon:</span>
                        <span>${location.latitude.toFixed(6)}, ${location.longitude.toFixed(6)}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Accuracy:</span>
                        <span>${location.horizontalAccuracy ? location.horizontalAccuracy.toFixed(1) + 'm' : 'N/A'}</span>
                    </div>
                </div>
            `;
        }

        // Create visit popup content
        function createVisitPopupContent(visit, isArrival) {
            const type = isArrival ? 'Arrival' : (visit.departureDate ? 'Departure' : 'Visit');
            // Handle both arrivalDate/departureDate and plain timestamp
            const dateField = isArrival
                ? (visit.arrivalDate || visit.timestamp)
                : (visit.departureDate || visit.timestamp);
            const date = new Date(dateField).toLocaleString();

            return `
                <div class="popup-content">
                    <div class="popup-activity">
                        <div class="popup-activity-dot" style="background: ${isArrival ? '#22c55e' : '#ef4444'};"></div>
                        <span>${type}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Time:</span>
                        <span>${date}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Lat/Lon:</span>
                        <span>${visit.latitude.toFixed(6)}, ${visit.longitude.toFixed(6)}</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Accuracy:</span>
                        <span>${visit.horizontalAccuracy ? visit.horizontalAccuracy.toFixed(1) + 'm' : 'N/A'}</span>
                    </div>
                </div>
            `;
        }

        // Render location markers
        function renderLocations() {
            // Clear existing markers
            locationMarkers.forEach(marker => map.removeLayer(marker));
            locationMarkers = [];

            // Get filter values
            const startDate = document.getElementById('date-start').value
                ? parseLocalDate(document.getElementById('date-start').value).getTime()
                : -Infinity;
            const endDate = document.getElementById('date-end').value
                ? parseLocalDate(document.getElementById('date-end').value).setHours(23, 59, 59, 999)
                : Infinity;

            const showLocations = document.getElementById('toggle-locations').checked;
            if (!showLocations) return;

            // Get activity filters
            const activityFilters = {};
            document.querySelectorAll('[data-activity]').forEach(checkbox => {
                activityFilters[checkbox.dataset.activity] = checkbox.checked;
            });

            // Filter and render locations
            locationsData.forEach(location => {
                const locationTime = new Date(location.timestamp).getTime();

                // Date filter
                if (locationTime < startDate || locationTime > endDate) return;

                // Find matching motion activity
                const motion = findNearestMotion(location.timestamp, motionData);
                const activity = getActivityType(motion);

                // Activity filter
                if (!activityFilters[activity]) return;

                // Create marker
                const marker = L.circleMarker([location.latitude, location.longitude], {
                    radius: 6,
                    fillColor: ACTIVITY_COLORS[activity],
                    color: '#ffffff',
                    weight: 1,
                    opacity: 1,
                    fillOpacity: 0.8
                });

                marker.bindPopup(createPopupContent(location, activity, motion));
                marker.addTo(map);
                locationMarkers.push(marker);
            });

            fitMapBounds();
        }

        // Render visit markers
        function renderVisits() {
            // Clear existing markers
            visitMarkers.forEach(marker => map.removeLayer(marker));
            visitMarkers = [];

            const showVisits = document.getElementById('toggle-visits').checked;
            if (!showVisits) return;

            // Get filter values
            const startDate = document.getElementById('date-start').value
                ? parseLocalDate(document.getElementById('date-start').value).getTime()
                : -Infinity;
            const endDate = document.getElementById('date-end').value
                ? parseLocalDate(document.getElementById('date-end').value).setHours(23, 59, 59, 999)
                : Infinity;

            visitsData.forEach(visit => {
                // Support both arrivalDate/departureDate format and plain timestamp format
                const arrivalTime = visit.arrivalDate
                    ? new Date(visit.arrivalDate).getTime()
                    : (visit.timestamp ? new Date(visit.timestamp).getTime() : null);
                const departureTime = visit.departureDate ? new Date(visit.departureDate).getTime() : null;

                // Arrival/Visit marker (green square)
                if (arrivalTime && arrivalTime >= startDate && arrivalTime <= endDate) {
                    const arrivalMarker = L.marker([visit.latitude, visit.longitude], {
                        icon: L.divIcon({
                            className: 'visit-marker',
                            html: `<div style="background: #22c55e; width: 12px; height: 12px; border-radius: 2px; border: 2px solid white;"></div>`,
                            iconSize: [12, 12]
                        })
                    });
                    arrivalMarker.bindPopup(createVisitPopupContent(visit, true));
                    arrivalMarker.addTo(map);
                    visitMarkers.push(arrivalMarker);
                }

                // Departure marker (red square) - only if we have separate departure time
                if (departureTime && departureTime >= startDate && departureTime <= endDate) {
                    const departureMarker = L.marker([visit.latitude, visit.longitude], {
                        icon: L.divIcon({
                            className: 'visit-marker',
                            html: `<div style="background: #ef4444; width: 12px; height: 12px; border-radius: 2px; border: 2px solid white;"></div>`,
                            iconSize: [12, 12]
                        })
                    });
                    departureMarker.bindPopup(createVisitPopupContent(visit, false));
                    departureMarker.addTo(map);
                    visitMarkers.push(departureMarker);
                }
            });

            fitMapBounds();
        }

        // Fit map to visible markers
        function fitMapBounds() {
            const allMarkers = [...locationMarkers, ...visitMarkers];
            if (allMarkers.length === 0) return;

            const group = L.featureGroup(allMarkers);
            map.fitBounds(group.getBounds(), { padding: [50, 50] });
        }

        // Update statistics
        function updateStats() {
            document.getElementById('stat-locations').textContent = locationsData.length.toLocaleString();
            document.getElementById('stat-visits').textContent = visitsData.length.toLocaleString();

            if (locationsData.length > 0) {
                const timestamps = locationsData.map(l => new Date(l.timestamp).getTime());
                const minDate = new Date(Math.min(...timestamps));
                const maxDate = new Date(Math.max(...timestamps));
                document.getElementById('stat-daterange').textContent =
                    `${minDate.toLocaleDateString()} - ${maxDate.toLocaleDateString()}`;
            }
        }

        // Create frequency chart
        function createFrequencyChart() {
            const timestamps = locationsData.map(l => {
                const ts = l.timestamp || l.serverTimestamp;
                return new Date(ts);
            });

            // Group by date
            const dateCounts = {};
            timestamps.forEach(ts => {
                const dateKey = ts.toISOString().split('T')[0];
                dateCounts[dateKey] = (dateCounts[dateKey] || 0) + 1;
            });

            // Sort dates
            const sortedDates = Object.keys(dateCounts).sort();
            const counts = sortedDates.map(date => dateCounts[date]);

            // Format labels - parse date string as local time, not UTC
            const labels = sortedDates.map(date => {
                const [year, month, day] = date.split('-').map(Number);
                const d = new Date(year, month - 1, day);  // Local time
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            });

            const ctx = document.getElementById('frequency-chart').getContext('2d');
            const darkMode = isDarkMode();

            chart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Uploads',
                        data: counts,
                        backgroundColor: '#3b82f6',
                        borderColor: '#2563eb',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280'
                            },
                            grid: {
                                color: darkMode ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Convert Firestore Timestamp to ISO string
        function convertTimestamp(value) {
            if (value && typeof value.toDate === 'function') {
                return value.toDate().toISOString();
            }
            return value;
        }

        // Convert Firestore document to plain object
        function convertDocument(doc) {
            const data = doc.data();
            const converted = { id: doc.id };

            for (const [key, value] of Object.entries(data)) {
                if (value && typeof value.toDate === 'function') {
                    // Firestore Timestamp
                    converted[key] = value.toDate().toISOString();
                } else if (value && typeof value.latitude === 'number' && typeof value.longitude === 'number') {
                    // Firestore GeoPoint
                    converted[key] = { latitude: value.latitude, longitude: value.longitude };
                } else {
                    converted[key] = value;
                }
            }
            return converted;
        }

        // Query Firestore for data within date range
        async function queryFirestoreData(startDate, endDate) {
            const db = window.firestoreDB;
            const query = window.firestoreQuery;
            const collection = window.firestoreCollection;
            const where = window.firestoreWhere;
            const orderBy = window.firestoreOrderBy;
            const getDocs = window.firestoreGetDocs;
            const Timestamp = window.firestoreTimestamp;
            const userId = window.FIRESTORE_USER_ID;

            // Convert dates to Firestore Timestamps
            const startTimestamp = Timestamp.fromDate(startDate);
            const endTimestamp = Timestamp.fromDate(endDate);

            try {
                // Query locations
                const locationsQuery = query(
                    collection(db, 'user_locations'),
                    where('userId', '==', userId),
                    where('serverTimestamp', '>=', startTimestamp),
                    where('serverTimestamp', '<=', endTimestamp),
                    orderBy('serverTimestamp', 'desc')
                );
                const locationsSnapshot = await getDocs(locationsQuery);
                locationsData = locationsSnapshot.docs.map(convertDocument);

                // Query motion activities
                const motionQuery = query(
                    collection(db, 'user_motion_activities'),
                    where('userId', '==', userId),
                    where('serverTimestamp', '>=', startTimestamp),
                    where('serverTimestamp', '<=', endTimestamp),
                    orderBy('serverTimestamp', 'desc')
                );
                const motionSnapshot = await getDocs(motionQuery);
                motionData = motionSnapshot.docs.map(convertDocument);

                // Query visits
                const visitsQuery = query(
                    collection(db, 'user_visits'),
                    where('userId', '==', userId),
                    where('serverTimestamp', '>=', startTimestamp),
                    where('serverTimestamp', '<=', endTimestamp),
                    orderBy('serverTimestamp', 'desc')
                );
                const visitsSnapshot = await getDocs(visitsQuery);
                visitsData = visitsSnapshot.docs.map(convertDocument);

                // Sort motion data by timestamp for binary search
                motionData.sort((a, b) => new Date(a.timestamp || a.serverTimestamp).getTime() - new Date(b.timestamp || b.serverTimestamp).getTime());

                return true;
            } catch (error) {
                console.error('Error querying Firestore:', error);
                throw error;
            }
        }

        // Load data from Firestore with default 30-day range
        async function loadData() {
            try {
                // Default to last 30 days
                const endDate = new Date();
                endDate.setHours(23, 59, 59, 999);
                const startDate = new Date();
                startDate.setDate(startDate.getDate() - 30);
                startDate.setHours(0, 0, 0, 0);

                await queryFirestoreData(startDate, endDate);

                // Set date inputs to match the query range
                document.getElementById('date-start').value = startDate.toISOString().split('T')[0];
                document.getElementById('date-end').value = endDate.toISOString().split('T')[0];

                return true;
            } catch (error) {
                console.error('Error loading data:', error);
                alert('Error loading data from Firestore: ' + error.message);
                return false;
            }
        }

        // Re-query Firestore and refresh display when date range changes
        async function onDateRangeChange() {
            const startInput = document.getElementById('date-start').value;
            const endInput = document.getElementById('date-end').value;

            if (!startInput || !endInput) return;

            const startDate = parseLocalDate(startInput);
            startDate.setHours(0, 0, 0, 0);
            const endDate = parseLocalDate(endInput);
            endDate.setHours(23, 59, 59, 999);

            // Show loading overlay (doesn't affect layout)
            const loadingEl = document.getElementById('loading');
            loadingEl.textContent = 'Refreshing data...';
            loadingEl.classList.add('loading-overlay');
            loadingEl.style.display = 'flex';

            try {
                await queryFirestoreData(startDate, endDate);

                // Update UI
                updateStats();
                if (chart) {
                    chart.destroy();
                }
                createFrequencyChart();
                renderLocations();
                renderVisits();

                // Update analytics if that tab is active
                const analyticsView = document.getElementById('analytics-view');
                if (analyticsView && analyticsView.style.display !== 'none') {
                    renderAnalytics();
                }
            } catch (error) {
                console.error('Error refreshing data:', error);
                alert('Error refreshing data: ' + error.message);
            } finally {
                loadingEl.style.display = 'none';
                loadingEl.classList.remove('loading-overlay');
            }
        }

        // Setup entropy explainer popover
        function setupEntropyExplainer() {
            const infoIcon = document.getElementById('entropy-info-icon');
            const explainer = document.getElementById('entropy-explainer');

            if (!infoIcon || !explainer) return;

            let hideTimeout;

            function positionPopover() {
                const iconRect = infoIcon.getBoundingClientRect();
                const explainerRect = explainer.getBoundingClientRect();

                // Position below and slightly to the left of the icon
                let top = iconRect.bottom + 8;
                let left = iconRect.left - 10;

                // Check if popover would go off the right edge
                if (left + explainerRect.width > window.innerWidth - 10) {
                    left = window.innerWidth - explainerRect.width - 10;
                }

                // Check if popover would go off the left edge
                if (left < 10) {
                    left = 10;
                }

                // Check if popover would go off the bottom
                if (top + explainerRect.height > window.innerHeight - 10) {
                    top = iconRect.top - explainerRect.height - 8;
                }

                explainer.style.top = `${top}px`;
                explainer.style.left = `${left}px`;
            }

            infoIcon.addEventListener('mouseenter', () => {
                clearTimeout(hideTimeout);
                explainer.showPopover();
                requestAnimationFrame(positionPopover);
            });

            infoIcon.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    explainer.hidePopover();
                }, 200);
            });

            explainer.addEventListener('mouseenter', () => {
                clearTimeout(hideTimeout);
            });

            explainer.addEventListener('mouseleave', () => {
                hideTimeout = setTimeout(() => {
                    explainer.hidePopover();
                }, 200);
            });
        }

        // Mobile toggle setup
        function setupMobileToggle() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('mobile-toggle');
            const closeHeader = document.getElementById('mobile-close');
            const closeBtn = closeHeader.querySelector('.mobile-close-btn');

            function isMobile() {
                return window.innerWidth <= 768;
            }

            function openSidebar() {
                sidebar.classList.add('mobile-open');
                toggleBtn.innerHTML = '✕';
            }

            function closeSidebar() {
                sidebar.classList.remove('mobile-open');
                toggleBtn.innerHTML = '☰';
            }

            toggleBtn.addEventListener('click', () => {
                if (sidebar.classList.contains('mobile-open')) {
                    closeSidebar();
                } else {
                    openSidebar();
                }
            });

            closeBtn.addEventListener('click', closeSidebar);

            // Handle resize
            function handleResize() {
                if (isMobile()) {
                    toggleBtn.style.display = 'flex';
                    closeHeader.style.display = 'flex';
                    closeSidebar();
                } else {
                    toggleBtn.style.display = 'none';
                    closeHeader.style.display = 'none';
                    sidebar.classList.remove('mobile-open');
                }
            }

            window.addEventListener('resize', handleResize);
            handleResize();
        }

        // Initialize dashboard
        async function initDashboard() {
            applyDarkMode();

            const dataLoaded = await loadData();
            if (!dataLoaded) return;

            // Hide loading, show UI
            document.getElementById('loading').style.display = 'none';
            document.getElementById('sidebar').style.display = 'flex';
            document.getElementById('map').style.display = 'block';

            initMap();
            updateStats();
            createFrequencyChart();
            renderLocations();
            renderVisits();

            // Event listeners - re-query Firestore when date range changes
            document.getElementById('date-start').addEventListener('change', onDateRangeChange);
            document.getElementById('date-end').addEventListener('change', onDateRangeChange);

            // User selector event listener
            document.getElementById('user-selector').addEventListener('change', onUserChange);

            // Load available users (async, don't block)
            populateUserSelector();

            document.getElementById('toggle-locations').addEventListener('change', renderLocations);
            document.getElementById('toggle-visits').addEventListener('change', renderVisits);

            document.querySelectorAll('[data-activity]').forEach(checkbox => {
                checkbox.addEventListener('change', renderLocations);
            });

            // Legend item click handlers - sync with checkboxes
            document.querySelectorAll('.legend-item[data-legend]').forEach(legendItem => {
                const legendType = legendItem.dataset.legend;

                // Find corresponding checkbox or toggle
                let linkedControl;
                if (legendType === 'visits') {
                    linkedControl = document.getElementById('toggle-visits');
                } else {
                    linkedControl = document.querySelector(`[data-activity="${legendType}"]`);
                }

                if (!linkedControl) return;

                // Sync initial state
                if (!linkedControl.checked) {
                    legendItem.classList.add('disabled');
                }

                // Handle legend click
                legendItem.addEventListener('click', () => {
                    linkedControl.checked = !linkedControl.checked;
                    linkedControl.dispatchEvent(new Event('change'));

                    // Update legend visual state
                    if (linkedControl.checked) {
                        legendItem.classList.remove('disabled');
                    } else {
                        legendItem.classList.add('disabled');
                    }
                });

                // Update legend when checkbox changes
                linkedControl.addEventListener('change', () => {
                    if (linkedControl.checked) {
                        legendItem.classList.remove('disabled');
                    } else {
                        legendItem.classList.add('disabled');
                    }
                });
            });

            // Mobile toggle functionality
            setupMobileToggle();

            // Setup entropy explainer popover
            setupEntropyExplainer();

            // Tab switching handlers
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    switchTab(btn.dataset.tab);
                });
            });

            // Check for URL parameter to auto-switch tabs
            const urlParams = new URLSearchParams(window.location.search);
            const tabParam = urlParams.get('tab');
            if (tabParam === 'analytics') {
                switchTab('analytics');
            }

            // Watch for dark mode changes
            if (window.matchMedia) {
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
                    location.reload(); // Reload to update map tiles
                });
            }
        }

        // Wait for Firebase to be ready before starting
        function startApp() {
            if (window.firebaseReady) {
                initDashboard();
            } else {
                window.addEventListener('firebaseReady', initDashboard);
            }
            // Load build info
            loadBuildInfo();
        }

        // Fetch and display build info from GitHub
        async function loadBuildInfo() {
            const buildEl = document.getElementById('build-commit');
            if (!buildEl) return;

            try {
                const response = await fetch('https://api.github.com/repos/suelio-arts/mix-dashboard/commits/main');
                if (!response.ok) throw new Error('Failed to fetch');
                const data = await response.json();

                const sha = data.sha.substring(0, 7);
                const date = new Date(data.commit.committer.date);
                const formatted = date.toLocaleDateString('en-US', {
                    month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                });

                buildEl.textContent = `${sha} · ${formatted}`;
                buildEl.title = data.commit.message.split('\n')[0];
            } catch (e) {
                buildEl.textContent = 'Build info unavailable';
            }
        }

        // Analytics charts tracking
        let analyticsCharts = {};

        // Tab switching logic
        function switchTab(tabName) {
            const mapView = document.getElementById('map');
            const analyticsView = document.getElementById('analytics-view');
            const tabButtons = document.querySelectorAll('.tab-btn');

            tabButtons.forEach(btn => {
                if (btn.dataset.tab === tabName) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });

            if (tabName === 'analytics') {
                mapView.style.display = 'none';
                analyticsView.style.display = 'block';
                renderAnalytics();
            } else {
                mapView.style.display = 'block';
                analyticsView.style.display = 'none';
            }
        }

        // Calculate Haversine distance between two points
        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Calculate mobility entropy (Shannon entropy)
        function calculateMobilityEntropy() {
            if (locationsData.length === 0) return 0;

            // Grid locations into ~100m cells
            const cellCounts = {};
            locationsData.forEach(loc => {
                const cellLat = Math.round(loc.latitude * 1000);
                const cellLng = Math.round(loc.longitude * 1000);
                const cellKey = `${cellLat},${cellLng}`;
                cellCounts[cellKey] = (cellCounts[cellKey] || 0) + 1;
            });

            const total = locationsData.length;
            let entropy = 0;

            // Calculate Shannon entropy: H = -Σ(p_i * log2(p_i))
            Object.values(cellCounts).forEach(count => {
                const p = count / total;
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            });

            return entropy;
        }

        // Calculate average dwell time from away visits only (not home)
        function calculateAverageDwellTime() {
            const awayVisits = getAwayVisits();
            if (awayVisits.length === 0) return 0;

            const durations = [];
            awayVisits.forEach(visit => {
                if (visit.arrivalDate && visit.departureDate) {
                    const arrival = new Date(visit.arrivalDate).getTime();
                    const departure = new Date(visit.departureDate).getTime();
                    const duration = (departure - arrival) / 1000 / 60; // minutes
                    if (duration > 0) {
                        durations.push(duration);
                    }
                }
            });

            if (durations.length === 0) return 0;
            return durations.reduce((a, b) => a + b, 0) / durations.length;
        }

        // Calculate dwell time statistics from away visits
        function calculateDwellTimeStatistics() {
            const awayVisits = getAwayVisits();
            if (awayVisits.length === 0) {
                return {
                    median: 0,
                    p25: 0,
                    p75: 0,
                    uniquePlaces: 0,
                    totalVisits: 0
                };
            }

            const durations = [];
            awayVisits.forEach(visit => {
                if (visit.arrivalDate && visit.departureDate) {
                    const arrival = new Date(visit.arrivalDate).getTime();
                    const departure = new Date(visit.departureDate).getTime();
                    const duration = (departure - arrival) / 1000 / 60; // minutes
                    if (duration > 0) {
                        durations.push(duration);
                    }
                }
            });

            if (durations.length === 0) {
                return {
                    median: 0,
                    p25: 0,
                    p75: 0,
                    uniquePlaces: 0,
                    totalVisits: 0
                };
            }

            // Sort durations for percentile calculations
            const sorted = [...durations].sort((a, b) => a - b);

            // Calculate percentiles
            const getPercentile = (arr, p) => {
                const index = Math.ceil(arr.length * p) - 1;
                return arr[Math.max(0, index)];
            };

            const median = getPercentile(sorted, 0.5);
            const p25 = getPercentile(sorted, 0.25);
            const p75 = getPercentile(sorted, 0.75);

            // Calculate unique places (grid-based clustering at ~100m resolution)
            const uniqueLocations = new Set();
            awayVisits.forEach(visit => {
                const cellLat = Math.round(visit.latitude * 1000);
                const cellLng = Math.round(visit.longitude * 1000);
                uniqueLocations.add(`${cellLat},${cellLng}`);
            });

            return {
                median,
                p25,
                p75,
                uniquePlaces: uniqueLocations.size,
                totalVisits: durations.length
            };
        }

        // Get dwell time distribution buckets
        function getDwellTimeDistribution() {
            const awayVisits = getAwayVisits();

            const buckets = {
                '0-5 min': 0,
                '5-15 min': 0,
                '15-30 min': 0,
                '30-60 min': 0,
                '1-2 hrs': 0,
                '2-4 hrs': 0,
                '4+ hrs': 0
            };

            awayVisits.forEach(visit => {
                if (visit.arrivalDate && visit.departureDate) {
                    const arrival = new Date(visit.arrivalDate).getTime();
                    const departure = new Date(visit.departureDate).getTime();
                    const minutes = (departure - arrival) / 1000 / 60;

                    if (minutes > 0) {
                        if (minutes < 5) buckets['0-5 min']++;
                        else if (minutes < 15) buckets['5-15 min']++;
                        else if (minutes < 30) buckets['15-30 min']++;
                        else if (minutes < 60) buckets['30-60 min']++;
                        else if (minutes < 120) buckets['1-2 hrs']++;
                        else if (minutes < 240) buckets['2-4 hrs']++;
                        else buckets['4+ hrs']++;
                    }
                }
            });

            return buckets;
        }

        // Calculate total distance traveled
        function calculateTotalDistance() {
            if (locationsData.length < 2) return 0;

            const sorted = [...locationsData].sort((a, b) =>
                new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
            );

            let totalDistance = 0;
            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const curr = sorted[i];
                totalDistance += haversineDistance(
                    prev.latitude, prev.longitude,
                    curr.latitude, curr.longitude
                );
            }

            return totalDistance;
        }

        // Count unique active days
        function countActiveDays() {
            if (locationsData.length === 0) return 0;

            const uniqueDays = new Set();
            locationsData.forEach(loc => {
                const date = new Date(loc.timestamp).toISOString().split('T')[0];
                uniqueDays.add(date);
            });

            return uniqueDays.size;
        }

        // Format distance for display
        function formatDistance(meters) {
            if (meters >= 1000) {
                return (meters / 1000).toFixed(1) + ' km';
            }
            return meters.toFixed(0) + ' m';
        }

        // Format duration for display
        function formatDuration(minutes) {
            if (minutes >= 60) {
                return (minutes / 60).toFixed(1) + ' hrs';
            }
            return minutes.toFixed(0) + ' min';
        }

        // Destroy all analytics charts
        function destroyAnalyticsCharts() {
            // Destroy Leaflet maps FIRST (before resetting object)
            if (analyticsCharts.homeDetectionMap) {
                analyticsCharts.homeDetectionMap.remove();
            }
            if (analyticsCharts.attachmentMap) {
                analyticsCharts.attachmentMap.remove();
            }

            // Destroy Chart.js charts (includes Walk Score charts)
            Object.entries(analyticsCharts).forEach(([key, chart]) => {
                if (key !== 'homeDetectionMap' && key !== 'attachmentMap' && chart && typeof chart.destroy === 'function') {
                    chart.destroy();
                }
            });

            analyticsCharts = {};
        }

        // Detect home clusters using nighttime density (proper DBSCAN expansion)
        function detectHomeClusters() {
            const nighttimePoints = locationsData.filter(loc => {
                const hour = new Date(loc.timestamp).getHours();
                return hour >= 22 || hour < 6;
            });

            if (nighttimePoints.length === 0) return [];

            // DBSCAN-like clustering with proper expansion
            const CLUSTER_RADIUS = 500; // meters
            const clusters = [];
            const visited = new Set();

            nighttimePoints.forEach((point, idx) => {
                if (visited.has(idx)) return;

                const cluster = [point];
                visited.add(idx);
                const queue = [idx]; // Queue for proper cluster expansion

                // Expand cluster by checking neighbors of all added points
                while (queue.length > 0) {
                    const currentIdx = queue.shift();
                    const currentPoint = nighttimePoints[currentIdx];

                    nighttimePoints.forEach((otherPoint, otherIdx) => {
                        if (visited.has(otherIdx)) return;

                        const distance = haversineDistance(
                            currentPoint.latitude, currentPoint.longitude,
                            otherPoint.latitude, otherPoint.longitude
                        );

                        if (distance <= CLUSTER_RADIUS) {
                            cluster.push(otherPoint);
                            visited.add(otherIdx);
                            queue.push(otherIdx); // Add to queue for further expansion
                        }
                    });
                }

                clusters.push(cluster);
            });

            // Calculate centroids and percentages
            return clusters.map(cluster => {
                const lat = cluster.reduce((sum, p) => sum + p.latitude, 0) / cluster.length;
                const lng = cluster.reduce((sum, p) => sum + p.longitude, 0) / cluster.length;
                const percentage = (cluster.length / nighttimePoints.length) * 100;
                return { lat, lng, count: cluster.length, percentage };
            }).sort((a, b) => b.count - a.count);
        }

        // Filter visits to only include those NOT within 500m of any detected home
        function getAwayVisits() {
            const homes = detectHomeClusters();
            if (homes.length === 0) return visitsData;

            const HOME_THRESHOLD = 500; // meters

            return visitsData.filter(visit => {
                // Check distance to all detected homes
                const distancesToHomes = homes.map(home =>
                    haversineDistance(home.lat, home.lng, visit.latitude, visit.longitude)
                );
                const minDistance = Math.min(...distancesToHomes);

                // Only include if farther than 500m from ALL homes
                return minDistance > HOME_THRESHOLD;
            });
        }

        // ============================================================
        // VENUE LOOKUP
        // ============================================================

        const VENUE_CACHE_KEY = 'mix-venue-cache';
        const VENUE_CACHE_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days

        function getVenueCache() {
            try {
                const cached = localStorage.getItem(VENUE_CACHE_KEY);
                return cached ? JSON.parse(cached) : {};
            } catch (e) {
                return {};
            }
        }

        function saveVenueCache(cache) {
            try {
                localStorage.setItem(VENUE_CACHE_KEY, JSON.stringify(cache));
            } catch (e) {}
        }

        // ============================================================
        // GEOCODING CACHE (for city lookup)
        // ============================================================

        const GEOCODING_CACHE_KEY = 'mix-geocoding-cache';
        const GEOCODING_CACHE_TTL = 90 * 24 * 60 * 60 * 1000; // 90 days

        function getGeocodingCache() {
            try {
                const cached = localStorage.getItem(GEOCODING_CACHE_KEY);
                return cached ? JSON.parse(cached) : {};
            } catch (e) {
                return {};
            }
        }

        function saveGeocodingCache(cache) {
            try {
                localStorage.setItem(GEOCODING_CACHE_KEY, JSON.stringify(cache));
            } catch (e) {}
        }

        // Reverse geocode to get city name using Geoapify (rate limited: 1 req/sec on DEMO key)
        async function reverseGeocode(lat, lon) {
            const cacheKey = `${lat.toFixed(3)},${lon.toFixed(3)}`;
            const cache = getGeocodingCache();

            // Check cache first
            if (cache[cacheKey] && (Date.now() - cache[cacheKey].fetchedAt) < GEOCODING_CACHE_TTL) {
                return cache[cacheKey].city;
            }

            try {
                // Use DEMO key with rate limiting (1 req/sec)
                await new Promise(resolve => setTimeout(resolve, 1000)); // Rate limit delay
                const response = await fetch(
                    `https://api.geoapify.com/v1/geocode/reverse?lat=${lat}&lon=${lon}&apiKey=DEMO`
                );
                if (!response.ok) throw new Error('Geocode failed');
                const data = await response.json();
                const props = data.features?.[0]?.properties || {};
                const city = props.city || props.county || props.state || 'Unknown';

                // Cache the result
                cache[cacheKey] = { city, fetchedAt: Date.now() };
                saveGeocodingCache(cache);
                return city;
            } catch (error) {
                console.warn('Reverse geocoding failed:', error);
                return 'Unknown';
            }
        }

        // ============================================================
        // END GEOCODING CACHE
        // ============================================================

        // Lookup nearby venue using Nominatim (OpenStreetMap - free, rate limited 1 req/sec)
        async function lookupVenue(lat, lng) {
            const cacheKey = `${lat.toFixed(4)},${lng.toFixed(4)}`;
            const cache = getVenueCache();

            if (cache[cacheKey] && (Date.now() - cache[cacheKey].fetchedAt) < VENUE_CACHE_TTL) {
                return cache[cacheKey].venue;
            }

            // Rate limiting for Nominatim
            const now = Date.now();
            if (!window._lastNominatimRequest) window._lastNominatimRequest = 0;
            const timeSinceLast = now - window._lastNominatimRequest;
            if (timeSinceLast < 1000) {
                await new Promise(resolve => setTimeout(resolve, 1000 - timeSinceLast));
            }
            window._lastNominatimRequest = Date.now();

            try {
                const url = `https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lng}&format=json&zoom=18&addressdetails=1`;
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'MIX Dashboard (Location Analytics)'
                    }
                });

                if (!response.ok) throw new Error('Nominatim failed');
                const data = await response.json();

                const addr = data.address || {};
                const venue = {
                    name: data.name || addr.amenity || addr.shop || addr.building || addr.road || addr.neighbourhood || 'Unknown Location',
                    category: addr.amenity || addr.shop || addr.building || addr.leisure || addr.tourism || data.type || 'location',
                    address: data.display_name || ''
                };

                cache[cacheKey] = { venue, fetchedAt: Date.now() };
                saveVenueCache(cache);
                return venue;
            } catch (error) {
                console.warn('Venue lookup failed:', error);
                return { name: `${lat.toFixed(4)}, ${lng.toFixed(4)}`, category: 'coordinates', address: '' };
            }
        }

        // ============================================================
        // END VENUE LOOKUP
        // ============================================================

        // ============================================================
        // PLACE ATTACHMENT ANALYTICS
        // ============================================================

        // Cluster visits by location using DBSCAN-like algorithm
        function clusterVisitsByLocation() {
            const awayVisits = getAwayVisits();
            if (awayVisits.length === 0) return [];

            const CLUSTER_RADIUS = 50; // 50m radius for place clustering
            const clusters = [];
            const visited = new Set();

            awayVisits.forEach((visit, idx) => {
                if (visited.has(idx)) return;

                const cluster = {
                    visits: [visit],
                    visitIndices: [idx]
                };
                visited.add(idx);
                const queue = [idx];

                // DBSCAN-like clustering
                while (queue.length > 0) {
                    const currentIdx = queue.shift();
                    const currentVisit = awayVisits[currentIdx];

                    awayVisits.forEach((otherVisit, otherIdx) => {
                        if (visited.has(otherIdx)) return;

                        const distance = haversineDistance(
                            currentVisit.latitude, currentVisit.longitude,
                            otherVisit.latitude, otherVisit.longitude
                        );

                        if (distance <= CLUSTER_RADIUS) {
                            cluster.visits.push(otherVisit);
                            cluster.visitIndices.push(otherIdx);
                            visited.add(otherIdx);
                            queue.push(otherIdx);
                        }
                    });
                }

                clusters.push(cluster);
            });

            return clusters;
        }

        // Calculate attachment score for a place cluster
        function calculateAttachmentScore(cluster) {
            if (cluster.visits.length === 0) return { score: 0 };

            // Get observation period in days
            const startInput = document.getElementById('date-start').value;
            const endInput = document.getElementById('date-end').value;
            const startDate = parseLocalDate(startInput);
            const endDate = parseLocalDate(endInput);
            const observationDays = Math.max(1, (endDate - startDate) / (1000 * 60 * 60 * 24));

            // 1. Frequency: visits per day
            const frequency = cluster.visits.length / observationDays;

            // 2. Temporal Regularity: inverse of std dev of time between visits
            let regularity = 0;
            if (cluster.visits.length > 1) {
                const timestamps = cluster.visits
                    .filter(v => v.arrivalDate)
                    .map(v => new Date(v.arrivalDate).getTime())
                    .sort((a, b) => a - b);

                if (timestamps.length > 1) {
                    const intervals = [];
                    for (let i = 1; i < timestamps.length; i++) {
                        intervals.push((timestamps[i] - timestamps[i-1]) / (1000 * 60 * 60 * 24)); // days
                    }

                    if (intervals.length > 0) {
                        const meanInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                        const variance = intervals.reduce((sum, val) => sum + Math.pow(val - meanInterval, 2), 0) / intervals.length;
                        const stdDev = Math.sqrt(variance);

                        // Regularity is inverse of std dev, normalized
                        regularity = stdDev > 0 ? 1 / (1 + stdDev) : 1;
                    }
                }
            }

            // 3. Duration Investment: total time spent
            let totalDwellMinutes = 0;
            cluster.visits.forEach(visit => {
                if (visit.arrivalDate && visit.departureDate) {
                    const arrival = new Date(visit.arrivalDate).getTime();
                    const departure = new Date(visit.departureDate).getTime();
                    const duration = (departure - arrival) / 1000 / 60; // minutes
                    if (duration > 0) {
                        totalDwellMinutes += duration;
                    }
                }
            });

            // Normalize duration to hours per day
            const hoursPerDay = (totalDwellMinutes / 60) / observationDays;

            // Calculate centroid
            const lat = cluster.visits.reduce((sum, v) => sum + v.latitude, 0) / cluster.visits.length;
            const lng = cluster.visits.reduce((sum, v) => sum + v.longitude, 0) / cluster.visits.length;

            // Composite score
            const score = (frequency * 10) + (regularity * 5) + (hoursPerDay * 2);

            return {
                lat,
                lng,
                score,
                visitCount: cluster.visits.length,
                totalDwellMinutes,
                frequency,
                regularity
            };
        }

        // Get places with high attachment scores
        function getHighAttachmentPlaces() {
            const clusters = clusterVisitsByLocation();
            const placesWithScores = clusters.map(cluster => calculateAttachmentScore(cluster));
            placesWithScores.sort((a, b) => b.score - a.score);
            return placesWithScores;
        }

        // Render Place Attachment analytics
        async function renderPlaceAttachment() {
            const places = getHighAttachmentPlaces();
            const topPlaces = places.slice(0, 10);

            // Update summary stats
            const highAttachmentThreshold = places.length > 0 ? places[0].score * 0.5 : 0;
            const highAttachmentCount = places.filter(p => p.score >= highAttachmentThreshold).length;
            document.getElementById('stat-high-attachment-count').textContent = highAttachmentCount;

            if (topPlaces.length > 0) {
                const avgVisits = topPlaces.reduce((sum, p) => sum + p.visitCount, 0) / topPlaces.length;
                document.getElementById('stat-avg-visits-top').textContent = avgVisits.toFixed(1);
            } else {
                document.getElementById('stat-avg-visits-top').textContent = '0';
            }

            // Lookup venues for all places
            const placesWithVenues = await Promise.all(
                topPlaces.map(async (place) => ({
                    ...place,
                    venue: await lookupVenue(place.lat, place.lng)
                }))
            );

            // Populate table
            const tbody = document.getElementById('attachment-table-body');
            if (placesWithVenues.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px; color: var(--mix-text-muted);">No places found</td></tr>';
            } else {
                tbody.innerHTML = placesWithVenues.map((place, idx) => {
                    const coords = `${place.lat.toFixed(4)}, ${place.lng.toFixed(4)}`;
                    return `
                        <tr style="border-bottom: 1px solid var(--mix-border);">
                            <td style="padding: 8px 4px; color: var(--mix-text-muted);">${idx + 1}</td>
                            <td style="padding: 8px 4px; color: var(--mix-text);" title="${coords}">
                                <div style="font-size: 12px;">${place.venue.name}</div>
                                <div style="font-size: 10px; color: var(--mix-text-muted); text-transform: capitalize;">${place.venue.category}</div>
                            </td>
                            <td style="padding: 8px 4px; text-align: right; color: var(--mix-text); font-weight: 600;">${place.score.toFixed(1)}</td>
                            <td style="padding: 8px 4px; text-align: right; color: var(--mix-text);">${place.visitCount}</td>
                        </tr>
                    `;
                }).join('');
            }

            // Create mini map
            const container = document.getElementById('attachment-map');
            container.innerHTML = '';

            if (placesWithVenues.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: var(--mix-text-muted);">No data available</div>';
                return;
            }

            const darkMode = isDarkMode();
            const tileUrl = darkMode
                ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';

            const attachmentMap = L.map(container).setView([0, 0], 2);
            L.tileLayer(tileUrl, {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                subdomains: 'abcd',
                maxZoom: 19,
                detectRetina: true
            }).addTo(attachmentMap);

            const markers = [];

            // Add markers for top places with color coding by attachment level
            placesWithVenues.forEach((place, idx) => {
                let color;
                if (idx < 3) {
                    color = '#8b5cf6'; // High attachment - purple
                } else if (idx < 6) {
                    color = '#a78bfa'; // Medium attachment - light purple
                } else {
                    color = '#22d3ee'; // Lower attachment - cyan
                }

                const coords = `${place.lat.toFixed(4)}, ${place.lng.toFixed(4)}`;
                const marker = L.circleMarker([place.lat, place.lng], {
                    radius: 8,
                    fillColor: color,
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(attachmentMap).bindPopup(`
                    <div class="popup-content">
                        <div style="font-weight: 700; margin-bottom: 8px; color: var(--mix-text);">${place.venue.name}</div>
                        <div style="font-size: 10px; color: var(--mix-text-muted); margin-bottom: 8px; text-transform: capitalize;">
                            ${place.venue.category} • Rank ${idx + 1}
                        </div>
                        <div style="font-size: 11px;">
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;">
                                <span style="color: var(--mix-text-muted);">Attachment Score:</span>
                                <span style="color: var(--mix-text); font-weight: 600;">${place.score.toFixed(1)}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;">
                                <span style="color: var(--mix-text-muted);">Visits:</span>
                                <span style="color: var(--mix-text);">${place.visitCount}</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; padding: 4px 0;">
                                <span style="color: var(--mix-text-muted);">Total Time:</span>
                                <span style="color: var(--mix-text);">${formatDuration(place.totalDwellMinutes)}</span>
                            </div>
                            <div style="font-size: 9px; color: var(--mix-text-muted); margin-top: 8px; font-family: monospace;">
                                ${coords}
                            </div>
                        </div>
                    </div>
                `);

                markers.push(marker);
            });

            // Fit bounds to show all markers
            if (markers.length > 0) {
                const group = L.featureGroup(markers);
                attachmentMap.fitBounds(group.getBounds(), { padding: [30, 30] });
            }

            analyticsCharts.attachmentMap = attachmentMap;
        }

        // ============================================================
        // END PLACE ATTACHMENT ANALYTICS
        // ============================================================

        // ============================================================
        // WALK SCORE ANALYTICS
        // ============================================================

        // Walk Score cache in localStorage
        const WALKSCORE_CACHE_KEY = 'walkscore_cache_v1';
        const WALKSCORE_CACHE_TTL = 30 * 24 * 60 * 60 * 1000; // 30 days

        // Get cached Walk Score data
        function getWalkScoreCache() {
            try {
                const cached = localStorage.getItem(WALKSCORE_CACHE_KEY);
                if (!cached) return {};
                return JSON.parse(cached);
            } catch (e) {
                return {};
            }
        }

        // Save Walk Score to cache
        function saveWalkScoreCache(cache) {
            try {
                localStorage.setItem(WALKSCORE_CACHE_KEY, JSON.stringify(cache));
            } catch (e) {
                console.warn('Failed to save Walk Score cache:', e);
            }
        }

        // Get grid cell key for a coordinate (~200m resolution)
        function getWalkScoreGridKey(lat, lon) {
            // Round to ~200m grid (0.002 degrees ~ 200m)
            const gridLat = Math.round(lat / 0.002) * 0.002;
            const gridLon = Math.round(lon / 0.002) * 0.002;
            return `${gridLat.toFixed(3)},${gridLon.toFixed(3)}`;
        }

        // Get Walk Score category
        function getWalkScoreCategory(score) {
            if (score >= 90) return { label: "Walker's Paradise", bucket: 'high', color: '#22c55e' };
            if (score >= 70) return { label: 'Very Walkable', bucket: 'high', color: '#84cc16' };
            if (score >= 50) return { label: 'Somewhat Walkable', bucket: 'medium', color: '#eab308' };
            if (score >= 25) return { label: 'Car-Dependent', bucket: 'low', color: '#f97316' };
            return { label: 'Almost All Errands Require a Car', bucket: 'very-low', color: '#ef4444' };
        }

        // Fetch Walk Score from Firebase function
        async function fetchWalkScore(lat, lon) {
            const gridKey = getWalkScoreGridKey(lat, lon);
            const cache = getWalkScoreCache();

            // Check cache first
            if (cache[gridKey] && (Date.now() - cache[gridKey].fetchedAt) < WALKSCORE_CACHE_TTL) {
                return cache[gridKey].score;
            }

            // Try to call Firebase function
            try {
                if (!window.firebaseFunctions || !window.httpsCallable) {
                    console.warn('Firebase Functions not initialized');
                    return null;
                }
                const getWalkScoreFn = window.httpsCallable(window.firebaseFunctions, 'getWalkScore');
                const result = await getWalkScoreFn({ lat, lon });
                const score = result.data.walkscore;

                // Cache the result
                cache[gridKey] = { score, fetchedAt: Date.now() };
                saveWalkScoreCache(cache);

                return score;
            } catch (error) {
                console.warn('Walk Score fetch failed:', error.message);
                return null;
            }
        }

        // Estimate Walk Score based on location density (fallback when API unavailable)
        // This uses the locations data to estimate walkability from visit patterns
        // Excludes home locations for consistency with other Walk Score analytics
        function estimateWalkScoreFromData() {
            if (locationsData.length === 0) return null;

            // Get home clusters to exclude
            const homes = detectHomeClusters();
            const HOME_THRESHOLD = 500;

            // Filter to away locations
            const awayLocations = homes.length === 0 ? locationsData : locationsData.filter(loc => {
                const distancesToHomes = homes.map(home =>
                    haversineDistance(home.lat, home.lng, loc.latitude, loc.longitude)
                );
                return Math.min(...distancesToHomes) > HOME_THRESHOLD;
            });

            if (awayLocations.length === 0) return null;

            // Grid-based estimation: areas with more walking activity likely have higher walkability
            const gridScores = {};

            // Count walking vs other activities per grid cell
            awayLocations.forEach(loc => {
                const gridKey = getWalkScoreGridKey(loc.latitude, loc.longitude);
                if (!gridScores[gridKey]) {
                    gridScores[gridKey] = { walking: 0, other: 0, total: 0 };
                }

                const motion = findNearestMotion(loc.timestamp, motionData);
                const activity = getActivityType(motion);

                gridScores[gridKey].total++;
                if (activity === 'walking') {
                    gridScores[gridKey].walking++;
                } else {
                    gridScores[gridKey].other++;
                }
            });

            // Estimate scores: higher walking ratio = higher estimated walkability
            // This is a rough heuristic, not actual Walk Score data
            const estimatedScores = {};
            Object.entries(gridScores).forEach(([key, data]) => {
                const walkingRatio = data.walking / data.total;
                // Scale to 0-100, with baseline of 30 for any visited area
                estimatedScores[key] = Math.round(30 + (walkingRatio * 70));
            });

            return estimatedScores;
        }

        // Get Walk Scores for all location grid cells (with caching)
        async function getWalkScoresForLocations() {
            const cache = getWalkScoreCache();
            const gridCells = new Map(); // gridKey -> {lat, lon, count}

            // Collect unique grid cells from locations with counts
            locationsData.forEach(loc => {
                const gridKey = getWalkScoreGridKey(loc.latitude, loc.longitude);
                if (!gridCells.has(gridKey)) {
                    gridCells.set(gridKey, { lat: loc.latitude, lon: loc.longitude, count: 1 });
                } else {
                    gridCells.get(gridKey).count++;
                }
            });

            const scores = {};
            const uncachedCells = [];

            // Check cache for each cell
            gridCells.forEach((data, gridKey) => {
                if (cache[gridKey] && (Date.now() - cache[gridKey].fetchedAt) < WALKSCORE_CACHE_TTL) {
                    scores[gridKey] = cache[gridKey].score;
                } else {
                    uncachedCells.push({ gridKey, ...data });
                }
            });

            // Fetch real Walk Scores for uncached cells (prioritize by time spent)
            if (uncachedCells.length > 0 && window.firebaseFunctions) {
                // Sort by count (most visited first) and limit to avoid too many API calls
                uncachedCells.sort((a, b) => b.count - a.count);
                const toFetch = uncachedCells.slice(0, 20); // Fetch top 20 most visited

                updateWalkScoreStatus(`Fetching Walk Scores for ${toFetch.length} locations...`);

                for (const cell of toFetch) {
                    try {
                        const score = await fetchWalkScore(cell.lat, cell.lon);
                        if (score !== null) {
                            scores[cell.gridKey] = score;
                        }
                    } catch (e) {
                        console.warn('Failed to fetch Walk Score for', cell.gridKey);
                    }
                }

                // For remaining uncached cells, use estimated scores
                const stillUncached = uncachedCells.slice(20);
                if (stillUncached.length > 0) {
                    const estimated = estimateWalkScoreFromData();
                    if (estimated) {
                        stillUncached.forEach(cell => {
                            if (!scores[cell.gridKey] && estimated[cell.gridKey] !== undefined) {
                                scores[cell.gridKey] = estimated[cell.gridKey];
                            }
                        });
                    }
                }
            } else if (uncachedCells.length > 0) {
                // No Firebase Functions available, use estimated scores
                const estimated = estimateWalkScoreFromData();
                if (estimated) {
                    uncachedCells.forEach(cell => {
                        if (estimated[cell.gridKey] !== undefined) {
                            scores[cell.gridKey] = estimated[cell.gridKey];
                        }
                    });
                }
            }

            return scores;
        }

        // Calculate Walk Score analytics (excludes home locations)
        function calculateWalkScoreAnalytics(walkScores) {
            if (!walkScores || Object.keys(walkScores).length === 0) {
                return null;
            }

            // Get home clusters to exclude home locations
            const homes = detectHomeClusters();
            const HOME_THRESHOLD = 500; // meters

            // Filter to only away locations
            const awayLocations = homes.length === 0 ? locationsData : locationsData.filter(loc => {
                const distancesToHomes = homes.map(home =>
                    haversineDistance(home.lat, home.lng, loc.latitude, loc.longitude)
                );
                const minDistance = Math.min(...distancesToHomes);
                return minDistance > HOME_THRESHOLD;
            });

            if (awayLocations.length === 0) {
                return null;
            }

            // Group locations by grid cell and activity
            const cellData = {};
            let totalPoints = 0;

            awayLocations.forEach(loc => {
                const gridKey = getWalkScoreGridKey(loc.latitude, loc.longitude);
                const score = walkScores[gridKey];
                if (score === undefined) return;

                if (!cellData[gridKey]) {
                    // Parse lat/lon from gridKey
                    const [lat, lon] = gridKey.split(',').map(parseFloat);
                    cellData[gridKey] = {
                        score,
                        walking: 0,
                        other: 0,
                        total: 0,
                        lat,
                        lon
                    };
                }

                const motion = findNearestMotion(loc.timestamp, motionData);
                const activity = getActivityType(motion);

                cellData[gridKey].total++;
                totalPoints++;
                if (activity === 'walking') {
                    cellData[gridKey].walking++;
                } else {
                    cellData[gridKey].other++;
                }
            });

            if (totalPoints === 0) return null;

            // Calculate time-weighted average Walk Score
            let weightedScoreSum = 0;
            let totalWeight = 0;
            Object.values(cellData).forEach(cell => {
                weightedScoreSum += cell.score * cell.total;
                totalWeight += cell.total;
            });
            const weightedAvgScore = totalWeight > 0 ? weightedScoreSum / totalWeight : 0;

            // Calculate simple average
            const scores = Object.values(cellData).map(c => c.score);
            const avgScore = scores.reduce((a, b) => a + b, 0) / scores.length;

            // Calculate walking rate by walkability zone
            const zones = {
                high: { points: 0, walking: 0 },      // 70-100
                medium: { points: 0, walking: 0 },    // 50-69
                low: { points: 0, walking: 0 },       // 25-49
                veryLow: { points: 0, walking: 0 }    // 0-24
            };

            Object.values(cellData).forEach(cell => {
                let zone;
                if (cell.score >= 70) zone = 'high';
                else if (cell.score >= 50) zone = 'medium';
                else if (cell.score >= 25) zone = 'low';
                else zone = 'veryLow';

                zones[zone].points += cell.total;
                zones[zone].walking += cell.walking;
            });

            // Calculate walking percentages per zone
            const walkingRateByZone = {};
            Object.entries(zones).forEach(([zone, data]) => {
                walkingRateByZone[zone] = data.points > 0 ? (data.walking / data.points) * 100 : 0;
            });

            // Calculate overall walking rate
            let totalWalking = 0;
            Object.values(cellData).forEach(cell => totalWalking += cell.walking);
            const overallWalkingRate = (totalWalking / totalPoints) * 100;

            // Calculate expected walking rate based on weighted Walk Score
            // Heuristic: Walk Score 100 → ~70% walking max, linear scale
            const expectedWalkingRate = (weightedAvgScore / 100) * 70;

            // Walking efficiency index
            const efficiencyIndex = expectedWalkingRate > 0 ? overallWalkingRate / expectedWalkingRate : 0;

            return {
                avgScore: Math.round(avgScore),
                weightedAvgScore: Math.round(weightedAvgScore),
                walkingRateByZone,
                timeByZone: {
                    high: zones.high.points,
                    medium: zones.medium.points,
                    low: zones.low.points,
                    veryLow: zones.veryLow.points
                },
                overallWalkingRate,
                expectedWalkingRate,
                efficiencyIndex,
                cellData
            };
        }

        // Create Walk Score zone chart (donut/pie)
        function createWalkabilityZoneChart(analytics) {
            const card = document.getElementById('walkability-zone-card');
            const ctx = document.getElementById('walkability-zone-chart');
            if (!ctx) {
                if (card) card.classList.remove('card-loading');
                return;
            }

            const darkMode = isDarkMode();
            const timeByZone = analytics.timeByZone;
            const totalTime = timeByZone.high + timeByZone.medium + timeByZone.low + timeByZone.veryLow;

            if (totalTime === 0) {
                ctx.parentElement.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No walkability data</div>';
                if (card) card.classList.remove('card-loading');
                return;
            }

            // Convert to hours (assuming ~5min per point)
            const AVG_INTERVAL = 5 / 60;

            analyticsCharts.walkabilityZone = new Chart(ctx.getContext('2d'), {
                type: 'doughnut',
                data: {
                    labels: ['High (70-100)', 'Medium (50-69)', 'Low (25-49)', 'Very Low (0-24)'],
                    datasets: [{
                        data: [
                            (timeByZone.high * AVG_INTERVAL).toFixed(1),
                            (timeByZone.medium * AVG_INTERVAL).toFixed(1),
                            (timeByZone.low * AVG_INTERVAL).toFixed(1),
                            (timeByZone.veryLow * AVG_INTERVAL).toFixed(1)
                        ],
                        backgroundColor: ['#22c55e', '#eab308', '#f97316', '#ef4444'],
                        borderColor: darkMode ? '#1f2937' : '#ffffff',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: darkMode ? '#d1d5db' : '#4b5563',
                                padding: 10,
                                font: { size: 11 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.label}: ${context.raw} hrs`;
                                }
                            }
                        }
                    }
                }
            });

            if (card) card.classList.remove('card-loading');
        }

        // Create Walking vs Walk Score scatter chart (with reverse geocoding for city grouping)
        async function createWalkingVsWalkscoreChart(analytics) {
            console.log('createWalkingVsWalkscoreChart called', { analytics });
            const card = document.getElementById('walking-vs-walkscore-card');

            const ctx = document.getElementById('walking-vs-walkscore-chart');
            if (!ctx) {
                console.warn('walking-vs-walkscore-chart canvas not found');
                if (card) card.classList.remove('card-loading');
                return;
            }

            const darkMode = isDarkMode();
            const cellData = analytics.cellData;

            // Geocode all cells and aggregate by city
            const cityData = {}; // city -> { points: [...], totalDataPoints: N, totalWalkScore: N }
            const cellsArray = Object.entries(cellData);
            console.log('Processing cells for chart:', cellsArray.length, 'total cells');

            // First, try to use cached geocoding data
            const geocodingCache = getGeocodingCache();
            const cellsWithCities = [];

            for (const [gridKey, cell] of cellsArray) {
                // Defensive check for lat/lon
                if (cell.lat === undefined || cell.lon === undefined) {
                    console.warn('Cell missing lat/lon:', { gridKey, cell });
                    continue;
                }

                const cacheKey = `${cell.lat.toFixed(3)},${cell.lon.toFixed(3)}`;
                let city = 'Unknown';

                if (geocodingCache[cacheKey] && (Date.now() - geocodingCache[cacheKey].fetchedAt) < GEOCODING_CACHE_TTL) {
                    city = geocodingCache[cacheKey].city;
                } else {
                    // Will geocode later for top cells only
                    city = null;
                }

                cellsWithCities.push({ gridKey, cell, city, cacheKey });
            }

            console.log('Cells with valid lat/lon:', cellsWithCities.length);

            // Identify cells to geocode (prioritize by data points)
            // Only geocode top 5 cells to avoid long delays (rate limited to 1/sec)
            const cellsToGeocode = cellsWithCities
                .filter(item => item.city === null)
                .sort((a, b) => b.cell.total - a.cell.total)
                .slice(0, 5);

            // Geocode with timeout per cell
            const geocodeWithTimeout = (lat, lon, timeout = 5000) => {
                return Promise.race([
                    reverseGeocode(lat, lon),
                    new Promise((_, reject) =>
                        setTimeout(() => reject(new Error('Geocoding timeout')), timeout)
                    )
                ]);
            };

            for (const item of cellsToGeocode) {
                try {
                    item.city = await geocodeWithTimeout(item.cell.lat, item.cell.lon);
                } catch (error) {
                    console.warn('Failed to geocode', item.cell.lat, item.cell.lon, error.message);
                    item.city = 'Unknown';
                }
            }

            // Aggregate by city
            cellsWithCities.forEach(({ cell, city }) => {
                if (!city) city = 'Unknown';

                if (!cityData[city]) {
                    cityData[city] = {
                        points: [],
                        totalDataPoints: 0,
                        totalWalkScore: 0
                    };
                }

                const walkingPct = cell.total > 0 ? (cell.walking / cell.total) * 100 : 0;

                cityData[city].points.push({
                    x: cell.score,
                    y: walkingPct,
                    r: Math.min(Math.sqrt(cell.total) * 2, 15),
                    lat: cell.lat,
                    lon: cell.lon,
                    city: city
                });
                cityData[city].totalDataPoints += cell.total;
                cityData[city].totalWalkScore += cell.score;
            });

            // Identify top 4 cities by total data points (most visited)
            const citiesByVisits = Object.entries(cityData)
                .sort((a, b) => b[1].totalDataPoints - a[1].totalDataPoints)
                .slice(0, 4);

            const topCities = new Set(citiesByVisits.map(([city]) => city));

            // Color palette for top 4 cities - grayscale
            const cityColors = {
                0: { bg: 'rgba(255, 255, 255, 0.6)', border: '#ffffff' },   // White
                1: { bg: 'rgba(204, 204, 204, 0.6)', border: '#cccccc' },  // Light gray
                2: { bg: 'rgba(170, 170, 170, 0.6)', border: '#aaaaaa' },   // Medium gray
                3: { bg: 'rgba(136, 136, 136, 0.6)', border: '#888888' }   // Dark gray
            };
            const otherColor = { bg: 'rgba(102, 102, 102, 0.4)', border: '#666666' }; // Darker gray

            // Build datasets: one for each top city + one for "Other"
            const datasets = [];

            citiesByVisits.forEach(([city, data], idx) => {
                const color = cityColors[idx];
                datasets.push({
                    label: city,
                    data: data.points,
                    backgroundColor: color.bg,
                    borderColor: color.border,
                    borderWidth: 1
                });
            });

            // Add "Other" cities dataset
            Object.entries(cityData).forEach(([city, data]) => {
                if (!topCities.has(city)) {
                    datasets.push({
                        label: 'Other',
                        data: data.points,
                        backgroundColor: otherColor.bg,
                        borderColor: otherColor.border,
                        borderWidth: 1,
                        hidden: true // Hide by default
                    });
                }
            });

            // Expected walking line (Walk Score → expected walking %)
            datasets.push({
                label: 'Expected Rate',
                data: [{ x: 0, y: 0 }, { x: 100, y: 70 }],
                type: 'line',
                borderColor: '#9ca3af',
                borderDash: [5, 5],
                borderWidth: 2,
                pointRadius: 0,
                pointStyle: 'line',
                fill: false
            });

            console.log('Chart datasets:', datasets.length, 'datasets with',
                datasets.reduce((sum, d) => sum + (d.data?.length || 0), 0), 'total points');

            analyticsCharts.walkingVsWalkscore = new Chart(ctx.getContext('2d'), {
                type: 'bubble',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: darkMode ? '#d1d5db' : '#4b5563',
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.type === 'line') return null;
                                    const cityLabel = context.raw.city ? ` (${context.raw.city})` : '';
                                    return `Walk Score: ${context.raw.x}, Walking: ${context.raw.y.toFixed(1)}%${cityLabel}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Walk Score',
                                color: darkMode ? '#d1d5db' : '#6b7280'
                            },
                            min: 0,
                            max: 100,
                            ticks: { color: darkMode ? '#d1d5db' : '#6b7280' },
                            grid: { color: darkMode ? '#374151' : '#e5e7eb' }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Walking %',
                                color: darkMode ? '#d1d5db' : '#6b7280'
                            },
                            min: 0,
                            max: 100,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                callback: v => v + '%'
                            },
                            grid: { color: darkMode ? '#374151' : '#e5e7eb' }
                        }
                    }
                }
            });

            if (card) card.classList.remove('card-loading');
        }

        // Update Walk Score efficiency display
        function updateWalkingEfficiencyDisplay(analytics) {
            const card = document.getElementById('walking-efficiency-card');
            const valueEl = document.getElementById('efficiency-value');
            const labelEl = document.getElementById('efficiency-label');

            if (!analytics || analytics.efficiencyIndex === undefined) {
                valueEl.textContent = '--';
                labelEl.textContent = 'Insufficient data';
                if (card) card.classList.remove('card-loading');
                return;
            }

            const efficiency = analytics.efficiencyIndex;
            valueEl.textContent = efficiency.toFixed(2);

            // Color based on efficiency
            if (efficiency >= 1.2) {
                valueEl.style.color = '#22c55e';
                labelEl.textContent = 'Walking more than expected for your environment';
            } else if (efficiency >= 0.8) {
                valueEl.style.color = '#3b82f6';
                labelEl.textContent = 'Walking as expected for walkability level';
            } else if (efficiency >= 0.5) {
                valueEl.style.color = '#eab308';
                labelEl.textContent = 'Walking less than environment enables';
            } else {
                valueEl.style.color = '#ef4444';
                labelEl.textContent = 'Significantly underutilizing walkable areas';
            }

            if (card) card.classList.remove('card-loading');
        }

        // Update Walk Score statistics display
        function updateWalkScoreStatistics(analytics) {
            const card = document.getElementById('walkscore-stats-card');

            if (!analytics) {
                document.getElementById('stat-avg-walkscore').textContent = '--';
                document.getElementById('stat-weighted-walkscore').textContent = '--';
                document.getElementById('stat-walking-high').textContent = '--';
                document.getElementById('stat-walking-low').textContent = '--';
                if (card) card.classList.remove('card-loading');
                return;
            }

            document.getElementById('stat-avg-walkscore').textContent = analytics.avgScore;
            document.getElementById('stat-weighted-walkscore').textContent = analytics.weightedAvgScore;
            document.getElementById('stat-walking-high').textContent =
                analytics.walkingRateByZone.high.toFixed(1) + '%';
            document.getElementById('stat-walking-low').textContent =
                (analytics.walkingRateByZone.low + analytics.walkingRateByZone.veryLow > 0
                    ? ((analytics.walkingRateByZone.low * analytics.timeByZone.low +
                        analytics.walkingRateByZone.veryLow * analytics.timeByZone.veryLow) /
                        (analytics.timeByZone.low + analytics.timeByZone.veryLow || 1)).toFixed(1)
                    : '0.0') + '%';

            if (card) card.classList.remove('card-loading');
        }

        // Update Walk Score status message
        function updateWalkScoreStatus(message) {
            const statusEl = document.getElementById('walkscore-status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // Main function to render Walk Score analytics
        async function renderWalkScoreAnalytics() {
            updateWalkScoreStatus('Calculating walkability metrics...');

            // Add loading states to all Walk Score cards
            const headerCard = document.getElementById('walkscore-header');
            const efficiencyCard = document.getElementById('walking-efficiency-card');
            const zoneCard = document.getElementById('walkability-zone-card');
            const vsCard = document.getElementById('walking-vs-walkscore-card');
            const statsCard = document.getElementById('walkscore-stats-card');

            if (headerCard) headerCard.classList.add('card-loading');
            if (efficiencyCard) efficiencyCard.classList.add('card-loading');
            if (zoneCard) zoneCard.classList.add('card-loading');
            if (vsCard) vsCard.classList.add('card-loading');
            if (statsCard) statsCard.classList.add('card-loading');

            try {
                // Get Walk Scores (from cache or estimation)
                const walkScores = await getWalkScoresForLocations();

                if (!walkScores || Object.keys(walkScores).length === 0) {
                    updateWalkScoreStatus('No walkability data available. Configure Walk Score API for real data.');
                    updateWalkingEfficiencyDisplay(null);
                    updateWalkScoreStatistics(null);
                    // Remove loading states
                    if (headerCard) headerCard.classList.remove('card-loading');
                    if (efficiencyCard) efficiencyCard.classList.remove('card-loading');
                    if (zoneCard) zoneCard.classList.remove('card-loading');
                    if (vsCard) vsCard.classList.remove('card-loading');
                    if (statsCard) statsCard.classList.remove('card-loading');
                    return;
                }

                // Calculate analytics
                const analytics = calculateWalkScoreAnalytics(walkScores);

                if (!analytics) {
                    updateWalkScoreStatus('Insufficient location data for walkability analysis.');
                    // Remove loading states
                    if (headerCard) headerCard.classList.remove('card-loading');
                    if (efficiencyCard) efficiencyCard.classList.remove('card-loading');
                    if (zoneCard) zoneCard.classList.remove('card-loading');
                    if (vsCard) vsCard.classList.remove('card-loading');
                    if (statsCard) statsCard.classList.remove('card-loading');
                    return;
                }

                // Update status
                const cachedCount = Object.keys(walkScores).length;
                const cache = getWalkScoreCache();
                const realScoreCount = Object.keys(cache).filter(k => walkScores[k] !== undefined).length;
                if (realScoreCount > 0) {
                    updateWalkScoreStatus(`Analyzed ${cachedCount} grid cells (${realScoreCount} with real Walk Score data).`);
                } else {
                    updateWalkScoreStatus(`Analyzed ${cachedCount} grid cells. Using estimated scores.`);
                }

                // Remove header loading state once data is ready
                if (headerCard) headerCard.classList.remove('card-loading');

                // Render visualizations (each function removes its card's loading state)
                createWalkabilityZoneChart(analytics);
                await createWalkingVsWalkscoreChart(analytics);
                updateWalkingEfficiencyDisplay(analytics);
                updateWalkScoreStatistics(analytics);

            } catch (error) {
                console.error('Walk Score analytics error:', error);
                updateWalkScoreStatus('Error calculating walkability metrics: ' + error.message);
                // Remove loading states on error
                if (headerCard) headerCard.classList.remove('card-loading');
                if (efficiencyCard) efficiencyCard.classList.remove('card-loading');
                if (zoneCard) zoneCard.classList.remove('card-loading');
                if (vsCard) vsCard.classList.remove('card-loading');
                if (statsCard) statsCard.classList.remove('card-loading');
            }
        }

        // ============================================================
        // END WALK SCORE ANALYTICS
        // ============================================================

        // ============================================================
        // ACTIVITY INFERENCE FROM GPS SPEED
        // ============================================================

        // Speed thresholds for activity inference (m/s)
        const SPEED_THRESHOLDS = {
            stationary: 0.15,   // < 0.15 m/s = essentially not moving
            walking: 2.0,       // 0.15-2.0 m/s = walking (0.5-7.2 km/h)
            cycling: 8.0,       // 2.0-8.0 m/s = cycling (7.2-29 km/h)
            // > 8.0 m/s = driving
        };

        // Calculate speed and inferred activity between consecutive GPS points
        function calculateSpeedAndActivity(locations) {
            if (locations.length < 2) return [];

            // Sort by timestamp
            const sorted = [...locations].sort((a, b) =>
                new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()
            );

            const results = [];

            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const curr = sorted[i];

                const distance = haversineDistance(
                    prev.latitude, prev.longitude,
                    curr.latitude, curr.longitude
                );

                const timeDeltaMs = new Date(curr.timestamp).getTime() - new Date(prev.timestamp).getTime();
                const timeDeltaSec = timeDeltaMs / 1000;

                // Skip if time gap is too large (> 10 minutes) or too small (< 1 second)
                if (timeDeltaSec > 600 || timeDeltaSec < 1) continue;

                const speed = distance / timeDeltaSec; // m/s

                // Skip unrealistic speeds (> 50 m/s = 180 km/h)
                if (speed > 50) continue;

                // Infer activity from speed
                let inferredActivity;
                if (speed < SPEED_THRESHOLDS.stationary) {
                    inferredActivity = 'stationary';
                } else if (speed < SPEED_THRESHOLDS.walking) {
                    inferredActivity = 'walking';
                } else if (speed < SPEED_THRESHOLDS.cycling) {
                    inferredActivity = 'cycling';
                } else {
                    inferredActivity = 'automotive';
                }

                // Get sensor activity for comparison
                const motion = findNearestMotion(curr.timestamp, motionData);
                let sensorActivity = 'unknown';
                if (motion) {
                    if (motion.isStationary) sensorActivity = 'stationary';
                    else if (motion.isWalking) sensorActivity = 'walking';
                    else if (motion.isRunning) sensorActivity = 'running';
                    else if (motion.isCycling) sensorActivity = 'cycling';
                    else if (motion.isAutomotive) sensorActivity = 'automotive';
                    else if (motion.isUnknown) sensorActivity = 'unknown';
                }

                results.push({
                    timestamp: curr.timestamp,
                    latitude: curr.latitude,
                    longitude: curr.longitude,
                    distance,
                    timeDeltaSec,
                    speed,
                    inferredActivity,
                    sensorActivity,
                    prevPoint: prev
                });
            }

            return results;
        }

        // Detect likely walking routes (consecutive walking-speed segments)
        function detectLikelyWalkingRoutes(speedData) {
            const routes = [];
            let currentRoute = null;
            const MIN_POINTS = 3; // Minimum 3 consecutive points to be a route

            for (const point of speedData) {
                if (point.inferredActivity === 'walking') {
                    if (!currentRoute) {
                        currentRoute = {
                            points: [point],
                            totalDistance: point.distance,
                            speeds: [point.speed]
                        };
                    } else {
                        currentRoute.points.push(point);
                        currentRoute.totalDistance += point.distance;
                        currentRoute.speeds.push(point.speed);
                    }
                } else {
                    // End current route if it has enough points
                    if (currentRoute && currentRoute.points.length >= MIN_POINTS) {
                        currentRoute.avgSpeed = currentRoute.speeds.reduce((a, b) => a + b, 0) / currentRoute.speeds.length;
                        routes.push(currentRoute);
                    }
                    currentRoute = null;
                }
            }

            // Don't forget the last route
            if (currentRoute && currentRoute.points.length >= MIN_POINTS) {
                currentRoute.avgSpeed = currentRoute.speeds.reduce((a, b) => a + b, 0) / currentRoute.speeds.length;
                routes.push(currentRoute);
            }

            return routes;
        }

        // Calculate activity inference analytics
        function calculateActivityInferenceAnalytics(speedData) {
            if (speedData.length === 0) return null;

            // Count inferred activities
            const inferredCounts = {
                stationary: 0,
                walking: 0,
                cycling: 0,
                automotive: 0
            };

            // Count sensor activities
            const sensorCounts = {
                stationary: 0,
                walking: 0,
                running: 0,
                cycling: 0,
                automotive: 0,
                unknown: 0
            };

            // Comparison metrics
            let agreementCount = 0;
            let unknownReclassified = 0;
            let unknownTotal = 0;

            // Speed bins for histogram
            const speedBins = {
                '0-0.5': 0,
                '0.5-1': 0,
                '1-2': 0,
                '2-4': 0,
                '4-8': 0,
                '8-15': 0,
                '15-30': 0,
                '30+': 0
            };

            speedData.forEach(point => {
                // Count inferred
                inferredCounts[point.inferredActivity]++;

                // Count sensor
                sensorCounts[point.sensorActivity]++;

                // Check agreement (simplified: both walking or both stationary, etc.)
                const inferredSimple = point.inferredActivity;
                const sensorSimple = point.sensorActivity === 'running' ? 'walking' : point.sensorActivity;
                if (sensorSimple !== 'unknown' && inferredSimple === sensorSimple) {
                    agreementCount++;
                }

                // Count unknown reclassified
                if (point.sensorActivity === 'unknown') {
                    unknownTotal++;
                    if (point.inferredActivity !== 'unknown') {
                        unknownReclassified++;
                    }
                }

                // Bin speeds (in m/s)
                const speed = point.speed;
                if (speed < 0.5) speedBins['0-0.5']++;
                else if (speed < 1) speedBins['0.5-1']++;
                else if (speed < 2) speedBins['1-2']++;
                else if (speed < 4) speedBins['2-4']++;
                else if (speed < 8) speedBins['4-8']++;
                else if (speed < 15) speedBins['8-15']++;
                else if (speed < 30) speedBins['15-30']++;
                else speedBins['30+']++;
            });

            // Detect walking routes
            const walkingRoutes = detectLikelyWalkingRoutes(speedData);

            // Calculate totals
            const totalWithSensor = speedData.filter(p => p.sensorActivity !== 'unknown').length;
            const agreementRate = totalWithSensor > 0 ? (agreementCount / totalWithSensor) * 100 : 0;
            const reclassifiedRate = unknownTotal > 0 ? (unknownReclassified / unknownTotal) * 100 : 0;

            // Total walking distance from routes
            const totalWalkingDistance = walkingRoutes.reduce((sum, r) => sum + r.totalDistance, 0);

            // Average walking speed from all walking points
            const walkingPoints = speedData.filter(p => p.inferredActivity === 'walking');
            const avgWalkingSpeed = walkingPoints.length > 0
                ? walkingPoints.reduce((sum, p) => sum + p.speed, 0) / walkingPoints.length
                : 0;

            return {
                inferredCounts,
                sensorCounts,
                agreementRate,
                reclassifiedRate,
                unknownTotal,
                unknownReclassified,
                speedBins,
                walkingRoutes,
                totalWalkingDistance,
                avgWalkingSpeed,
                totalPoints: speedData.length
            };
        }

        // Update inference status message
        function updateInferenceStatus(message) {
            const statusEl = document.getElementById('inference-status');
            if (statusEl) {
                statusEl.textContent = message;
            }
        }

        // Create inferred activity donut chart
        function createInferredActivityChart(analytics) {
            const ctx = document.getElementById('inferred-activity-chart');
            if (!ctx) return;

            if (analyticsCharts.inferredActivity) {
                analyticsCharts.inferredActivity.destroy();
            }

            const darkMode = isDarkMode();
            const data = analytics.inferredCounts;
            const total = Object.values(data).reduce((a, b) => a + b, 0);

            analyticsCharts.inferredActivity = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Stationary', 'Walking', 'Cycling', 'Driving'],
                    datasets: [{
                        data: [data.stationary, data.walking, data.cycling, data.automotive],
                        backgroundColor: [
                            ACTIVITY_COLORS.stationary,
                            ACTIVITY_COLORS.walking,
                            ACTIVITY_COLORS.cycling,
                            ACTIVITY_COLORS.automotive
                        ],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                color: darkMode ? '#d1d5db' : '#4b5563',
                                padding: 15,
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const pct = ((context.raw / total) * 100).toFixed(1);
                                    return `${context.label}: ${context.raw} (${pct}%)`;
                                }
                            }
                        }
                    }
                }
            });
        }

        // Create sensor vs inferred comparison chart
        function createSensorVsInferredChart(analytics) {
            const ctx = document.getElementById('sensor-vs-inferred-chart');
            if (!ctx) return;

            if (analyticsCharts.sensorVsInferred) {
                analyticsCharts.sensorVsInferred.destroy();
            }

            const darkMode = isDarkMode();

            // Prepare data for grouped bar chart
            const categories = ['Stationary', 'Walking', 'Cycling', 'Driving', 'Unknown'];
            const sensorData = [
                analytics.sensorCounts.stationary,
                analytics.sensorCounts.walking + analytics.sensorCounts.running,
                analytics.sensorCounts.cycling,
                analytics.sensorCounts.automotive,
                analytics.sensorCounts.unknown
            ];
            const inferredData = [
                analytics.inferredCounts.stationary,
                analytics.inferredCounts.walking,
                analytics.inferredCounts.cycling,
                analytics.inferredCounts.automotive,
                0 // Inferred never produces 'unknown'
            ];

            analyticsCharts.sensorVsInferred = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: categories,
                    datasets: [
                        {
                            label: 'Sensor',
                            data: sensorData,
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderColor: 'rgba(59, 130, 246, 1)',
                            borderWidth: 1
                        },
                        {
                            label: 'Inferred',
                            data: inferredData,
                            backgroundColor: 'rgba(168, 85, 247, 0.7)',
                            borderColor: 'rgba(168, 85, 247, 1)',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: {
                                color: darkMode ? '#d1d5db' : '#4b5563'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: darkMode ? '#9ca3af' : '#6b7280' },
                            grid: { color: darkMode ? '#374151' : '#e5e7eb' }
                        },
                        y: {
                            ticks: { color: darkMode ? '#9ca3af' : '#6b7280' },
                            grid: { color: darkMode ? '#374151' : '#e5e7eb' }
                        }
                    }
                }
            });
        }

        // Create speed histogram chart
        function createSpeedHistogramChart(analytics) {
            const ctx = document.getElementById('speed-histogram-chart');
            if (!ctx) return;

            if (analyticsCharts.speedHistogram) {
                analyticsCharts.speedHistogram.destroy();
            }

            const darkMode = isDarkMode();
            const bins = analytics.speedBins;

            // Color code bins by activity zone
            const binColors = [
                ACTIVITY_COLORS.stationary, // 0-0.5
                ACTIVITY_COLORS.walking,     // 0.5-1
                ACTIVITY_COLORS.walking,     // 1-2
                ACTIVITY_COLORS.cycling,     // 2-4
                ACTIVITY_COLORS.cycling,     // 4-8
                ACTIVITY_COLORS.automotive,  // 8-15
                ACTIVITY_COLORS.automotive,  // 15-30
                ACTIVITY_COLORS.automotive   // 30+
            ];

            analyticsCharts.speedHistogram = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['0-0.5', '0.5-1', '1-2', '2-4', '4-8', '8-15', '15-30', '30+'],
                    datasets: [{
                        label: 'GPS Point Pairs',
                        data: Object.values(bins),
                        backgroundColor: binColors.map(c => c + 'cc'),
                        borderColor: binColors,
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                title: function(context) {
                                    return `Speed: ${context[0].label} m/s`;
                                },
                                label: function(context) {
                                    const pct = ((context.raw / analytics.totalPoints) * 100).toFixed(1);
                                    return `${context.raw} point pairs (${pct}%)`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Speed (m/s)',
                                color: darkMode ? '#d1d5db' : '#6b7280'
                            },
                            ticks: { color: darkMode ? '#9ca3af' : '#6b7280' },
                            grid: { display: false }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Count',
                                color: darkMode ? '#d1d5db' : '#6b7280'
                            },
                            ticks: { color: darkMode ? '#9ca3af' : '#6b7280' },
                            grid: { color: darkMode ? '#374151' : '#e5e7eb' }
                        }
                    }
                }
            });
        }

        // Update walking routes statistics display
        function updateWalkingRoutesDisplay(analytics) {
            document.getElementById('stat-walking-segments').textContent =
                analytics.walkingRoutes.length.toLocaleString();

            document.getElementById('stat-walking-distance').textContent =
                (analytics.totalWalkingDistance / 1000).toFixed(2) + ' km';

            document.getElementById('stat-avg-walking-speed').textContent =
                analytics.avgWalkingSpeed.toFixed(2) + ' m/s (' +
                (analytics.avgWalkingSpeed * 3.6).toFixed(1) + ' km/h)';

            document.getElementById('stat-reclassified').textContent =
                analytics.reclassifiedRate.toFixed(1) + '% (' +
                analytics.unknownReclassified + '/' + analytics.unknownTotal + ')';
        }

        // Main function to render activity inference analytics
        function renderActivityInferenceAnalytics() {
            updateInferenceStatus('Calculating speed-based activity inference...');

            try {
                // Calculate speed and inferred activity for all GPS points
                const speedData = calculateSpeedAndActivity(locationsData);

                if (speedData.length === 0) {
                    updateInferenceStatus('Insufficient GPS data for activity inference.');
                    return;
                }

                // Calculate analytics
                const analytics = calculateActivityInferenceAnalytics(speedData);

                if (!analytics) {
                    updateInferenceStatus('Could not calculate activity inference metrics.');
                    return;
                }

                // Update status
                const unknownPct = (analytics.sensorCounts.unknown / analytics.totalPoints * 100).toFixed(1);
                updateInferenceStatus(
                    `Analyzed ${analytics.totalPoints.toLocaleString()} point pairs. ` +
                    `${unknownPct}% had unknown sensor data. ` +
                    `${analytics.agreementRate.toFixed(1)}% agreement where both available.`
                );

                // Update header summary metrics
                document.getElementById('inference-metric-points').textContent =
                    analytics.totalPoints.toLocaleString();
                document.getElementById('inference-metric-agreement').textContent =
                    analytics.agreementRate.toFixed(1) + '%';
                document.getElementById('inference-metric-reclassified').textContent =
                    analytics.reclassifiedRate.toFixed(0) + '%';
                document.getElementById('inference-metric-walking').textContent =
                    (analytics.totalWalkingDistance / 1000).toFixed(1) + ' km';

                // Render visualizations
                createInferredActivityChart(analytics);
                createSensorVsInferredChart(analytics);
                createSpeedHistogramChart(analytics);
                updateWalkingRoutesDisplay(analytics);

            } catch (error) {
                console.error('Activity inference error:', error);
                updateInferenceStatus('Error calculating activity inference: ' + error.message);
            }
        }

        // ============================================================
        // END ACTIVITY INFERENCE
        // ============================================================

        // Create home detection map
        function createHomeDetectionMap() {
            const container = document.getElementById('home-detection-map');
            container.innerHTML = '';

            const homes = detectHomeClusters();
            if (homes.length === 0) {
                container.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: #6b7280;">No nighttime data available</div>';
                return;
            }

            const darkMode = isDarkMode();
            const tileUrl = darkMode
                ? 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'
                : 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png';

            const homeMap = L.map(container).setView([0, 0], 2);
            L.tileLayer(tileUrl, {
                attribution: '&copy; OpenStreetMap &copy; CARTO',
                subdomains: 'abcd',
                maxZoom: 19,
                detectRetina: true
            }).addTo(homeMap);

            // Collect all markers to calculate bounds
            const markers = [];

            // Add markers for each detected home centroid only
            homes.forEach((home, idx) => {
                const isPrimary = idx === 0;
                const label = isPrimary ? 'Primary Home' : `Home ${idx + 1}`;
                const color = isPrimary ? '#3b82f6' : '#f97316';

                const marker = L.circleMarker([home.lat, home.lng], {
                    radius: 8,
                    fillColor: color,
                    color: '#ffffff',
                    weight: 2,
                    opacity: 1,
                    fillOpacity: 0.8
                }).addTo(homeMap).bindPopup(`
                    <strong>${label} - ${home.percentage.toFixed(1)}%</strong><br>
                    ${home.count} nighttime points
                `);

                markers.push(marker);

                // Draw 500m radius circle
                L.circle([home.lat, home.lng], {
                    radius: 500,
                    color: color,
                    fillColor: color,
                    fillOpacity: 0.1,
                    weight: 1
                }).addTo(homeMap);
            });

            // Fit bounds to show all home centroids
            if (markers.length > 0) {
                const group = L.featureGroup(markers);
                homeMap.fitBounds(group.getBounds(), { padding: [30, 30] });
            }

            analyticsCharts.homeDetectionMap = homeMap;
        }

        // Create daily exploration radius chart
        function createDailyExplorationChart() {
            const homes = detectHomeClusters();
            if (homes.length === 0 || locationsData.length === 0) return;

            const dailyMaxDistances = {};

            locationsData.forEach(loc => {
                const date = new Date(loc.timestamp).toISOString().split('T')[0];

                // Find distance to NEAREST home (not just primary)
                const distancesToHomes = homes.map(home =>
                    haversineDistance(home.lat, home.lng, loc.latitude, loc.longitude) / 1000
                );
                const distance = Math.min(...distancesToHomes);

                if (!dailyMaxDistances[date] || distance > dailyMaxDistances[date]) {
                    dailyMaxDistances[date] = distance;
                }
            });

            const sortedDates = Object.keys(dailyMaxDistances).sort();
            const maxDistances = sortedDates.map(date => dailyMaxDistances[date]);

            const labels = sortedDates.map(date => {
                const [year, month, day] = date.split('-').map(Number);
                const d = new Date(year, month - 1, day);
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            });

            const ctx = document.getElementById('daily-exploration-chart').getContext('2d');
            const darkMode = isDarkMode();

            analyticsCharts.dailyExploration = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Max Distance (km)',
                        data: maxDistances,
                        backgroundColor: maxDistances.map(d => d > 50 ? '#ef4444' : '#3b82f6'),
                        borderColor: maxDistances.map(d => d > 50 ? '#dc2626' : '#2563eb'),
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                callback: function(value) {
                                    return value.toFixed(0) + ' km';
                                }
                            },
                            grid: {
                                color: darkMode ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Create home vs away time chart
        function createHomeAwayChart() {
            const homes = detectHomeClusters();
            if (homes.length === 0 || locationsData.length === 0) return;

            const HOME_THRESHOLD = 500; // meters
            const dailyData = {};

            locationsData.forEach(loc => {
                const date = new Date(loc.timestamp).toISOString().split('T')[0];

                // Check if within 500m of ANY detected home
                const distancesToHomes = homes.map(home =>
                    haversineDistance(home.lat, home.lng, loc.latitude, loc.longitude)
                );
                const minDistance = Math.min(...distancesToHomes);
                const isHome = minDistance <= HOME_THRESHOLD;

                if (!dailyData[date]) {
                    dailyData[date] = { homeCount: 0, awayCount: 0 };
                }

                if (isHome) {
                    dailyData[date].homeCount++;
                } else {
                    dailyData[date].awayCount++;
                }
            });

            // Estimate hours (assuming location updates every 5 min on average)
            const AVG_UPDATE_INTERVAL = 5 / 60; // hours
            const sortedDates = Object.keys(dailyData).sort();
            const homeHours = sortedDates.map(date => dailyData[date].homeCount * AVG_UPDATE_INTERVAL);
            const awayHours = sortedDates.map(date => dailyData[date].awayCount * AVG_UPDATE_INTERVAL);

            const labels = sortedDates.map(date => {
                const [year, month, day] = date.split('-').map(Number);
                const d = new Date(year, month - 1, day);
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            });

            const ctx = document.getElementById('home-away-chart').getContext('2d');
            const darkMode = isDarkMode();

            analyticsCharts.homeAway = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'At Home',
                            data: homeHours,
                            backgroundColor: '#22c55e',
                            borderColor: '#16a34a',
                            borderWidth: 1
                        },
                        {
                            label: 'Away',
                            data: awayHours,
                            backgroundColor: '#ef4444',
                            borderColor: '#dc2626',
                            borderWidth: 1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: darkMode ? '#d1d5db' : '#4b5563'
                            }
                        }
                    },
                    scales: {
                        x: {
                            stacked: true,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            stacked: true,
                            beginAtZero: true,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                callback: function(value) {
                                    return value.toFixed(1) + ' hrs';
                                }
                            },
                            grid: {
                                color: darkMode ? '#374151' : '#e5e7eb'
                            }
                        }
                    }
                }
            });

            // Calculate average home time percentage
            const totalHome = homeHours.reduce((a, b) => a + b, 0);
            const totalAway = awayHours.reduce((a, b) => a + b, 0);
            const homePercentage = (totalHome / (totalHome + totalAway)) * 100;
            console.log(`Average time at home: ${homePercentage.toFixed(1)}%`);
        }

        // Create exploration variance display
        function createExplorationVariance() {
            const homes = detectHomeClusters();
            if (homes.length === 0 || locationsData.length === 0) return;

            const dailyMaxDistances = {};

            locationsData.forEach(loc => {
                const date = new Date(loc.timestamp).toISOString().split('T')[0];

                // Find distance to NEAREST home (not just primary)
                const distancesToHomes = homes.map(home =>
                    haversineDistance(home.lat, home.lng, loc.latitude, loc.longitude) / 1000
                );
                const distance = Math.min(...distancesToHomes);

                if (!dailyMaxDistances[date] || distance > dailyMaxDistances[date]) {
                    dailyMaxDistances[date] = distance;
                }
            });

            const distances = Object.values(dailyMaxDistances);
            const mean = distances.reduce((a, b) => a + b, 0) / distances.length;
            const variance = distances.reduce((sum, d) => sum + Math.pow(d - mean, 2), 0) / distances.length;
            const stdDev = Math.sqrt(variance);

            document.getElementById('variance-value').textContent = stdDev.toFixed(2);

            let label = '';
            if (stdDev < 5) {
                label = 'Very Routine - Consistent daily patterns';
            } else if (stdDev < 15) {
                label = 'Moderately Routine - Some variation';
            } else if (stdDev < 30) {
                label = 'Exploratory - Significant variation';
            } else {
                label = 'Highly Exploratory - Large day-to-day differences';
            }
            document.getElementById('variance-label').textContent = label;
        }

        // Create radius of gyration chart
        function createRadiusGyrationChart() {
            if (locationsData.length === 0) return;

            const homes = detectHomeClusters();
            const HOME_THRESHOLD = 500; // meters

            // Helper to find which home a point is near (returns home index or -1)
            function getNearestHomeIndex(lat, lng) {
                for (let i = 0; i < homes.length; i++) {
                    const dist = haversineDistance(homes[i].lat, homes[i].lng, lat, lng);
                    if (dist <= HOME_THRESHOLD) return i;
                }
                return -1;
            }

            // Group locations by day
            const dailyLocations = {};
            locationsData.forEach(loc => {
                const date = new Date(loc.timestamp).toISOString().split('T')[0];

                if (!dailyLocations[date]) {
                    dailyLocations[date] = [];
                }
                dailyLocations[date].push(loc);
            });

            // Filter to only days where start and end are at SAME home
            const validDays = {};
            let skippedTravelDays = 0;

            Object.entries(dailyLocations).forEach(([date, locs]) => {
                if (locs.length < 2) return; // Need at least 2 points

                // Sort by timestamp to get first and last
                const sorted = [...locs].sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                );

                const firstLoc = sorted[0];
                const lastLoc = sorted[sorted.length - 1];

                const startHomeIdx = getNearestHomeIndex(firstLoc.latitude, firstLoc.longitude);
                const endHomeIdx = getNearestHomeIndex(lastLoc.latitude, lastLoc.longitude);

                // Only include if started and ended at SAME home
                if (startHomeIdx >= 0 && startHomeIdx === endHomeIdx) {
                    validDays[date] = locs;
                } else {
                    skippedTravelDays++;
                }
            });

            console.log(`RoG: Including ${Object.keys(validDays).length} days, skipped ${skippedTravelDays} travel days`);

            // Calculate radius of gyration for each valid day
            const sortedDates = Object.keys(validDays).sort();
            const rogValues = sortedDates.map(date => {
                const points = validDays[date];

                // Calculate centroid
                const centroidLat = points.reduce((sum, p) => sum + p.latitude, 0) / points.length;
                const centroidLng = points.reduce((sum, p) => sum + p.longitude, 0) / points.length;

                // Calculate RoG: sqrt(sum(distance^2) / n)
                const sumSquaredDistances = points.reduce((sum, p) => {
                    const d = haversineDistance(centroidLat, centroidLng, p.latitude, p.longitude);
                    return sum + (d * d);
                }, 0);

                return Math.sqrt(sumSquaredDistances / points.length) / 1000; // km
            });

            const labels = sortedDates.map(date => {
                const [year, month, day] = date.split('-').map(Number);
                const d = new Date(year, month - 1, day);
                return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
            });

            const ctx = document.getElementById('radius-gyration-chart').getContext('2d');
            const darkMode = isDarkMode();

            analyticsCharts.radiusGyration = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Radius of Gyration (km)',
                        data: rogValues,
                        borderColor: '#9333ea',
                        backgroundColor: 'rgba(147, 51, 234, 0.1)',
                        fill: true,
                        tension: 0.3,
                        pointRadius: 4,
                        pointBackgroundColor: '#9333ea'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                callback: function(value) {
                                    return value.toFixed(1) + ' km';
                                }
                            },
                            grid: {
                                color: darkMode ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Create dwell time distribution chart
        function createDwellDistributionChart() {
            const distribution = getDwellTimeDistribution();
            const labels = Object.keys(distribution);
            const data = Object.values(distribution);

            const ctx = document.getElementById('dwell-distribution-chart').getContext('2d');
            const darkMode = isDarkMode();

            analyticsCharts.dwellDistribution = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Number of Visits',
                        data: data,
                        backgroundColor: '#3b82f6',
                        borderColor: '#2563eb',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                stepSize: 1
                            },
                            grid: {
                                color: darkMode ? '#374151' : '#e5e7eb'
                            }
                        },
                        x: {
                            ticks: {
                                color: darkMode ? '#d1d5db' : '#6b7280',
                                maxRotation: 45,
                                minRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Update dwell time statistics display
        function updateDwellTimeStatistics() {
            const stats = calculateDwellTimeStatistics();

            document.getElementById('stat-median').textContent = formatDuration(stats.median);
            document.getElementById('stat-p25').textContent = formatDuration(stats.p25);
            document.getElementById('stat-p75').textContent = formatDuration(stats.p75);
            document.getElementById('stat-unique-places').textContent = stats.uniquePlaces.toLocaleString();
            document.getElementById('stat-total-visits').textContent = stats.totalVisits.toLocaleString();
        }

        // Main render analytics function
        async function renderAnalytics() {
            // Destroy old charts
            destroyAnalyticsCharts();

            // Calculate and update metrics
            const entropy = calculateMobilityEntropy();
            document.getElementById('metric-entropy').textContent = entropy.toFixed(2);

            const dwellTime = calculateAverageDwellTime();
            document.getElementById('metric-dwell').textContent = formatDuration(dwellTime);

            const distance = calculateTotalDistance();
            document.getElementById('metric-distance').textContent = formatDistance(distance);

            const activeDays = countActiveDays();
            document.getElementById('metric-active-days').textContent = activeDays;

            // Create all spatial analytics charts
            createHomeDetectionMap();
            createDailyExplorationChart();
            createHomeAwayChart();
            createExplorationVariance();
            createRadiusGyrationChart();
            createDwellDistributionChart();
            updateDwellTimeStatistics();

            // Create Place Attachment analytics
            const placeCard = document.getElementById('place-attachment-card');
            if (placeCard) placeCard.classList.add('card-loading');
            await renderPlaceAttachment();
            if (placeCard) placeCard.classList.remove('card-loading');

            // Create Walk Score analytics
            renderWalkScoreAnalytics();

            // Create Activity Inference analytics
            renderActivityInferenceAnalytics();
        }

        // Start the app
        startApp();
    </script>
</body>
</html>
